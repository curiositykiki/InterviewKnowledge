## 前言

1. **竞态条件**

   竞态条件是指**同一个程序多线程访问同一个资源，如果对资源的访问顺序敏感，就称存在竞态条件**，代码区成为临界区。最常见的竞态条件为：先检测后执行。执行依赖于检测的结果，而检测结果依赖于多个线程的执行时序，而多个线程的执行时序通常情况下是不固定不可判断的，从而导致执行结果出现各种问题。

2. **Observer观察者模式**

   Observer模式定义**对象间的一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新**。



## 线程安全的对象生命期管理

1. **多线程下的析构函数**

   问题：析构的对象此时是否在运行？如何保证运行的对象不会被析构？如何得知一个对象正在析构？

   1. 什么是线程安全的class？

      ①多个线程同时访问，依然可以表现出正确的行为；

      ②可以任意调度任意交织；

      ③调用代码无须额外的同步；

   2. **boost::noncopyable**

      头文件：\#include<boost/noncopyable.hpp>   或  #include<boost/utility.hpp>

      作用：**禁止**自动生成默认复制构造函数和默认赋值运算符。

      使用方法：直接从boost::noncopyable公有派生。

      **class noncopyable** 的基本思想是把构造函数和析构函数设置 **protected** 权限，这样子类可以调用，但是外面的类不能调用，那么当子类需要定义构造函数的时候不至于通不过编译。但是最关键的是**noncopyable** 把复制构造函数和赋值运算符、做成了 **private**，这就意味着 **除非子类定义自己的copy构造和赋值函数，否则在子类没有定义的情况下，外面的调用者是不能够通过赋值和copy构造等手段来产生一个新的子类对象的**。此时如果对派生类调用复制或者赋值会直接报错。

2. 构造**线程安全的**对象的要求：在构造函数体内，不要泄露this指针。即，不要在构造体内注册任何回调；不要将this传递给跨线程对象；也不要return这个this指针（如果这个类是个基类，派生类还在创建当中，return这个this指针有可能出错）；

3. **空悬指针**：指向已经销毁的对象；**野指针**：未经初始化的指针。

4. 在面向对象的程序设计中，对象的关系主要有三种：**composition、aggregation、association。**

   ①composition（组合/复合），也就是在a对象持有一个b，**b作为a的一部分，所以是一个部分b只能被一个全体a所持有。**那么b的生命周期由a来把控，a析构的时候b也会析构；

   ②aggregation（聚合），与①类似，也是a对象持有一个b，但是不同的是，**b作为a的一部分，同时，这个部分b也可以作为其他全体a所持有的。**此时需要注意的是，a析构的时候需要考虑是否有别的a持有b，b不能简单析构；

   ③association（关联），相当于一种弱一点的聚合。①②表示的是**两个类对象**之间的关系，③表示的是**两个类**之间的关系。类a中拥有一个类b作为成员，同时类a会调用b的成员函数，就说明类ab单向关联，如果b也会类内部调用a的方法，则说明类ab双向关联。

5. **对象池**：为了解决由于**聚合、关联**造成的对象之间析构顺序不对容易导致内存泄漏或重复释放问题提出的方法，**只创建对象而不销毁对象**，使用完毕后放回对象池，需要的时候再从池中取出。但是也存在一些问题：

   ①线程池的线程安全，即多线程下如何保证对象使用安全、完整；

   ②可能发生LockContention（锁竞争），导致多个线程竞争开锁，多线程也会退化成串行操作；

   ③存在多种类怎么设计，每种类一个池？

   ④对象池不断增大，是不是会造成内存浪费？

6. **shared_ptr相关知识**

   1. 底层实现，shared_ptr是一个类对象，当初始化的时候，**其new了一个中间对象ptr_base，这个ptr_base有一个指向shared_ptr指向对象的指针，一个成员对象分别记录了指向该对象的shared和weak指针的数目。**注意，如果初始化shared的时候都是使用类对象，就会出现两个shared的计数都是1，释放的时候会重复释放的问题；正确方式是，**初始化第二个shared的时候使用第一个shared作为参数，调用复制构造函数，但是不会new新的对象，只是在那个对象计数上面+1。**此时的计数是正常的，析构的行为也会正常。使用use_count（）方法可以返回当前对象的引用数。

      shared_ptr用法：shared_ptr<T> \*p （new T（参数））

   2. **weak_ptr**也是引用计数型智能指针，但是**不增加对象的shared引用次数**，即弱引用。但是weak主要是为了**解决shared的循环引用（会导致内存泄漏）的问题**，要配合shared一起使用。**本身不能直接指向原始对象，也不能把weak赋予shared，只能指向shared。**拥有expired和lock方法，调用expired会返回bool**检查对象是否过期**；调用lock会返回**指向对象的指针**，使用shared_ptr<class> *sp = wp.lock()就可以了获得一个对象的shared，如果失败会返回0；

7. scoped_ptr和unique_ptr都是支持移动语义的**独占**指针，但是unique是STL的，但是scoped是boost库的。

8. **如何通过weak解决shared循环引用的问题？**

   一般引起循环引用的原因是**类对象拥有若干个shared指针，**因此必须将成员变量shared换成weak，因为shared可以直接赋予weak，所以使用逻辑上可以不变。同时，对shared指向的对象进行读写的时候，**首先取得互斥锁**，可以将weak升级为shared，通过weak.lock()返回对象即可。注意，这里升级得到的**shared必须在局部内使用，因为升级之后对象的shared计数会++，因此不会被析构。但是这只是暂时使用，在局部使用的好处是，这个函数执行完毕之后对应的shared会自动销毁。**这就避免了循环引用导致内存泄漏的问题。

   这种思想还可以应用于临界区对shared的读写，例如需要对shared读操作，需要使用互斥锁，**然后在临界区外先声明一个newshared，在临界区内将shared赋予newshared，然后退出临界区，此时再对对象进行读操作会更安全。**

9. **RAII（资源获取即初始化），**大概意思是**每一个明确的资源配置动作（如new），都应该在单一语句中执行，并在该语句中立刻将获得的资源交给handle（例如初始化的时候就用shared_ptr），程序中一般不会出现delete。**

10. **boost：：bind**用于绑定**函数与参数**，这里的函数可以是普通的函数，也可以是类成员函数，其包含了\_1~\_9九个占位符，表示最多可以接受带九个参数的函数；例如：

    有一个函数func（a1，a2），则

    boost：：bind（&func，\_1,\_2）（a1，a2）等价于boost：：bind（&func，\_2,\_1）（a2，a1）；

    对于类c的成员函数cs，有

    c c1；

    boost：：bind（&c：：cs，\_1,\_2）（c1，a2）；

11. 在shared有一个方法reset，作用是**这个指针不再指向之前那个对象了，那个对象的计数-1。**如果带有第一个参数，可以将这个指针指向第一个参数；第二个参数是一个函数符，在reset的同时执行的一个函数。**一般可以用boost：：bind（&func，this，_1）**，第一个参数是处理函数；第二个参数是当前类的一个对象的指针，有了this指针可以直接调用类成员变量和类成员函数；第三个指针说明这个函数需要一个参数，reset会将之前指向的对象当做参数给到这个func；

    但是会遇到一个问题，如果调用这个函数的时候，本来的类对象已经析构了，执行的过程中还想访问其类成员变量和函数是不可能的了。因此，可以使用一个shared来将其强行续命。

    **boost：：enable_shared_from_this<class T>是一个以其派生类为模板类型实参的基类模板，只要继承这个类，this指针就会强行变为shared。**那么在析构自身的时候，就会由于有shared在指向他，所以生命周期变长了。**此时变为boost：：bind（&func，shared_from_this()，_1）**，当我们执行func这个函数的时候，可以确保本身不会被析构。