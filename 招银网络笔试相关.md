1. 假设由**置换-选择**得到9个初始归并段，其长度（记录数）依次是：9,30,12,18,3,17,2,6,24.则利用3路平衡归并的最佳归并树进行归并排序，需要对外存放进行多少次读写次数（）

   A 446

   B 484

   C 242

   D 223

   正确答案为A，（30\*1+（9+12+59）\*2+11\*3）\*2=446。

   外部排序相关：

   0. 首先，如果有n个记录，采用m路归并算法，则首先将n个记录分成m个一组，得到r=n/m组初始归并段，则归并树的深度为log（m）r。**为了减少外存读写次数，可以通过增大m或者减小r来实现。**也就是增大m路归并，以及减小初始归并段的数量r。

   1. **置换-选择排序**：

      是用于生成初始归并段的一种方法，此方法有利于**减小初始归并段r**。例如我们有n条记录，如果直接按照m路归并划分，就会得到n/m条记录，太多了。所以使用置换-选择排序。具体为：

      1. 待排序文件FI存放n个记录，归并段文件FO清空，工作区WA能容纳k个记录，清空；
      2. 从FI中读入k个记录到WA，然后在WA中建立小顶堆，取得堆顶元素输出FO，并且记MIN为刚才输出的堆顶元素的值；
      3. 从FI中读入1个记录到WA，然后从**比MIN大的元素中**选择一个最小的输出到FO，更新MIN为刚才输出的元素；
      4. 重复3直到**找不到比MIN更大的元素**，此时得到一个归并段在FO；
      5. 以此类推，会得到**长度不一致的有序的初始归并段**；

      例如：序列17、21、5、44、10、12、56、32、29工作区WA大小为3，会得到

      ①5、17、21、44、56

      ②10、12、29、32

      两段初始归并段。

   2. **败者树**

      内部排序中，我们需要从m路中选择最小的一个元素输出。如果单纯增大m，则比较的次数会急剧增加，效率较低，因此引入败者树。败者树的思想可以参考堆排序，其将比较的复杂度从m降低到logm。

      例如，有b0~b4总共5路归并，我们将**比较的失败者放在父节点，然后将胜者送进上一层进行下一轮比较；**如下图：

      ![](img/gb1.png)

      b3和b4比较，b4输了，所以父节点为4，b3进入上一层和b0比较，b0输了就留在父节点；以此类推，直到输出胜者b3的第一个元素6；然后b3的下一个元素15进场再次重复刚才的比较路径；

      ![](img/gb2.png)

   3. **最佳归并树**

      我们得到了初始归并段之后，每一段的长度不一样，我们进行m路归并要有合适的排序顺序才能保证外存读写的次数最小，也就是要构建一棵m叉哈夫曼树。

      假设每个叶子节点的权重为其到达根节点的边数，那么可以计算带权路径长度WPL，在归并中有读写两步，所以**IO总次数为2\*WPL次。**

      1. 不是你有n个节点就能组成m叉哈夫曼树，我们怎么判断需要补充多少个虚节点才能组成m叉哈夫曼树呢？

         ①首先，我们直到一棵树的节点数==度数+1，且m叉哈夫曼树的节点度数要不为0，要不为m，不妨设度数为0的节点数n0=x，度数为m的节点数nm=y；

         ②我们得到x+y=my+1，转换一下，得到x=（m-1）y+1；我们已经知道x了，**但是必须保证此时的y为整数**，因此y=（x-1）/（m-1）；

         ③如果此时整除，就ok了；如果不能整除，即（x-1）%（m-1）=u，为了让x-1能被m-1整除，我们添加虚节点使得u+v=m-1，即添加v=（m-1）-u个节点；

      例如，有9段长度为别分2、3、6、9、12、17、18、24、30的初始归并段，现在要进行3路归并，求出需要多少次外存IO？

      很容易可以画出哈夫曼树：

      ![](img/hfm.png)

      根据公式2\*WPL=2\*（（2+3+6）\*3+（9+12+17+18+24）\*2+30\*1）=446次。





2. 下面描述中与C++泛型无关的是（）

   A 模板

   B 继承

   C Boost

   D RTTI

   正确答案为B。

   ①模板肯定跟泛型有关；

   ②继承无关；

   ③boost库是类似于STL库一样的存在，STL提供了很多模板类或者算法，boost库主要提供模板工具类；

   ④RTTI，运行阶段类型检测，跟这个泛型关系就比较大了；



3. 在C++中，要实现**动态绑定**必须使用（）调用虚函数A

   A 基类指针

   B 类名

   C 对象名

   D 派生类指针

   正确答案为A。动态绑定其实就是多态的意思啦，所以说到动态绑定，一般就是发生在**基类与派生类之间了**。一般来说，**non-virtual函数就是静态绑定，因为编译的时候就知道了是否运行该函数；virtual函数就是动态绑定，因为只有在运行的时候才知道是否运行该函数；**我们知道，基类的指针或者引用，才可以指向派生类对象，所以要实现动态绑定必须满足两个条件：

   ①函数为virtual；

   ②指针为基类的指针或者引用；





4. 分支定界算法中各节点最多有（）次机会成为活节点。

   

   A 0

   B 1

   C 2

   D 3

   正确答案为B。
   
   分支定界法其实就是我们的**搜索树剪枝的一种策略**。我们求解的问题是一个有约束的最优化问题，那么每一个分支就是一个可行解，当然每一个可行解可以有一个上界或者下界；我们可以根据上界或者下界断定，某一个分支继续细分之后有可能获得更优的解，对于那些上界或者下界不是最优解的分支可以直接去掉。在分支定界法中，每一个节点**只有1次机会成为活结点**。





5. 2M\*8的DRAM芯片需要多少个地址引脚：答案11

   首先2M=2^1\*1M=2^1\*2^10\*1K=2^1\*2^10\*2^10\*1B=2^21B，所以一般是需要21根地址引脚的，**但是DRAM的地址线在芯片中是分时复用的，所以只需要一半的地址线即可**，因此需要10.5？题目中有10就选10，没有就选11吧。然后8代表数据传输时8位的，所以需要8根数据线。





6. 算法题，求出N以内的素数。

   埃拉托斯特尼筛法，是一种由希腊数学家埃拉托斯特尼所提出的一种简单检定素数的算法。要得到自然数n以内的全部素数，**必须把不大于根号n的所有素数的倍数剔除，剩下的就是素数**。

   ①简单来说，就是**凡是素数的倍数，都不是素数**，所以只要把素数的倍数全部剔除，就只会剩下素数。

   ②那为什么是不大于根号n呢？考虑49=7\*7，也就是我们只要检查到49%7==0，就知道了49不是素数了；那么对于其他例如35=5\*7，我只要检查到35%5==0就知道35不是素数了，所以只要检查到不大于根号n的整数是否可以整除即可，这个也是暴力枚举最快的方法了；

   ③根据埃拉托斯特尼筛法，诞生了**欧拉筛选法**。这个算法的思想是将每一个合数都利用其最小的素数来将其筛选掉，在埃拉托斯特尼筛法中，35在5的倍数和7的倍数中都被检查了，所以35检查了两次；但是在欧拉筛选法中，35只有在7的倍数才会被检查到，所以效率更高了；算法如下：

   ```c++
   #include<iostream>
   #include<algorithm>
   #include<vector>
   using namespace std;
   void calprim(vector<int> &ans, int N, int &cnt) {
   	vector<bool> visit(N + 1, true);//记录visit[i]是否是一个素数
   	visit[0] = visit[1] = false;
   	for (int i = 2; i <= N; ++i) {
   		if (visit[i]) {//如果visit[i]==true，说明这个数是一个素数
   			ans.push_back(i);
   			cnt++;
   		}
   		for (int j = 0; j < cnt&&i*ans[j] <= N; ++j) {
   			visit[i*ans[j]] = false;//素数的倍数肯定不是素数
   			if (i%ans[j] == 0)//如果成立，则可以得到m=i/ans[j]，那么下一个检查点i*ans[j+1]联立解得
   				//i*ans[j+1]=m*ans[j]*ans[j+1]，也就是说，这个i*ans[j+1]是ans[j]的m*ans[j+1]倍，
   				//同时m*ans[j+1]>i，所以当我们检查到下一个更大的i的时候，自然会剔除当前的i*ans[j+1]，
   				//所以这里直接break就可以了。
   				//举例子说明当i=5时，5%5==0了，下一个检查点是5*7，但是m=i/ans[j]=1，说明35是5的m*ans[j+1]=7倍
   				//并且m*ans[j+1]>i即7>5，所以之后检查到7的时候自然会剔除35，这里就直接break了。
   				break;
   		}
   	}
   	return;
   }
   int main() {
   	int N;
   	cin >> N;
   	vector<int> ans;//记录素数
   	int cnt = 0;//记录有多少个素数
   	calprim(ans,N,cnt);
   	for (int i = 0; i < cnt; ++i)
   		cout << ans[i] << " ";
   	cout << endl;
   	return 0;
   }
   ```







7. 算法题，将IPV4的地址转换为IPV6。

   先普及一下IPV6地址的表示，我们知道**IPV4的地址长度为32位，IPV6的地址长度为128位！**所以IPV6的长度是IPV4的4倍，那么IPV4的一个实例为192.168.89.9，转换为IPV6的怎样的表示呢？

   答案是C0A8:5909。

   ①首先192/16=12，192%16=0，所以其十六进制的表示为C（12的十六进制表示）0；

   ②168/16=10，168%16=8，所以其表示为A8；

   ③89/16=5，89%16=9，所以其表示为59；

   ④9/16=0，9%16=9，所以其表示为09；

   ⑤IPV6中**每两位表示8位**，每个**冒号表示16位**，IPV4为32位，所以一个冒号就可以完全表示了；

   ```c++
   稍后再补
   ```





8. 常用的对称加密和非对称加密技术：

   1. 非对称加密技术：

      1. RSA：是目前最广泛使用的非对称加密技术，支付宝就是使用2048位RSA进行非对称加密的。实现原理：**根据数论，寻求两个大素数比较简单，而将它们的乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。**大概的过程为：

         ①任意选取两个不同的大素数p和q计算乘积n=pq，选定一个函数f，例如f（n）=（p-1）（q-1）；

         ②任意选择一个大整数e，使得gcd（e，f（n））=1，一般就是一个比p和q要大的素数；

         ③确定解密密钥d，满足（d\*e）%f（n）=1，也就是d\*e=kf（n）+1，这里的k是任意整数；

         ④公开n和e，自己保留d；

         ⑤将明文m转换为密文c，c=E（m）=（m^e）%n；

         ⑥将密文c还原为明文m，m=D（c）=（c^d）%n；

         ⑦只知道n和e是不可能求出d的，因此很安全；

         **⑧注意，用公钥加密可以用私钥解密，用私钥加密可以用公钥解密；**

      2. DSA即Digital Signature Algorithm，是一种公开的密钥算法，**不能用作加密，只用作数字签名**。DSA使用公开密钥，为接受者验证数据的完整性和数据发送者的身份。将数字签名和加密技术混合使用的步骤为：

         ①发送方A形成信息摘要M（一般就是使用一个hash），然后将自己的私人密钥SK和M进行DSA算法计算，产生数字签名Cm；

         ②对想要发送的信息P与加密后的摘要M一起用对称密钥加密（对称密钥是随机产生的）；

         ③用接收方的公开密钥加密对称密钥，形成Ck；

         ④将2、3步得到的结果发送给接收方B；

         ⑤B收到信息后用自己的私钥解密信息，得到对称密钥Ck；

         ⑥B用得到的对称密钥Ck解密剩下的信息，得到信息P与Cm；

         ⑦B用同样的Hash函数对P进行加密得到M',接收方用DSA算法对Cm和发送方的公开密钥进行计算得到M，如果M' = M ，则验证成功；

      3. ECDSA，是ECC（Elliptic curve cryptography，椭圆曲线密码学）和DSA的结合，相比于RSA算法，ECC 可以使用更小的秘钥，更高的效率，提供更高的安全保障，据称256位的ECC秘钥的安全性等同于3072位的RSA秘钥，和普通DSA相比，ECDSA在计算秘钥的过程中，部分因子使用了椭圆曲线算法。

   2. 对称加密技术：

      1. DES，Data Encryption Standard，即数据加密标准，是一种使用密钥加密的块算法。很基础的对称加密算法，但是已经被破解，无法使用。

         其原理大概是使用64位密钥（实际用到了56位，第8、16、24、32、40、48、56、64位是校验位， 使得每个密钥都有奇数个1），将64位输入数据重新排列，例如第58位数据跟第1位交换，第50位数据跟第2位交换等，解密就是再交换一次就行了。

         与3DES的对比，3DES是DES的更安全版本。它使用两个64位密钥，实际是有效的是112位，其他都是1。该方法使用两个密钥，执行三次DES算法，**加密的过程是加密-解密-加密，解密的过程是解密-加密-解密。**

      2. AES，密码学中的高级加密标准（Advanced Encryption Standard，AES），又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。最常用的对称加密算法，密钥建立时间短、灵敏性好、内存需求低。

      3. IDEA，常用的电子邮件加密算法。







9. ipv6地址转ipv4地址，实现IPv6和IPv4的映射一般使用？

   这里可以答NAT-PT协议，**NAT-PT(Network Address Translator - Protocol Translator)附带协议转换器的网络地址转换器**。是一种纯IPv6节点和IPv4节点间的互通方式，所有包括地址、协议在内的转换工作都由网络设备来完成。

   1. 静态NAT-PT
      静态模式提供了一对一的IPv6地址和IPv4地址的映射。IPv6单协议网络内的节点要访问的IPv4单协议网络内的每一个IPv4地址都必须在NAT-PT设备中设置。每一个目的IPv4地址在NAT-PT设备中被映射为一个具有预定义NAT-PT前缀的IPv6地址。这种模式中，每一个IPv6到IPv4映射需要一个源IPv4地址。静态NAT-PT模式跟IPv4中的静态NAT类似。
   2. 动态NAT-PT
      动态模式也提供了一对一的映射，但是使用一个IPv4地址池。池中的源IPv4地址数量决定了并发的IPv6到IPv4转换的最大数目。在IPv6网络中IPv6单协议网络节点动态地把预定义的NAT-PT前缀增加到目的IPv4地址。这种模式需要一个IPv4地址池来执行动态的地址转换，动态NAT-PT模式和IPv4中的动态NAT类似。
   3. NAPT-PT
      网络地址端口转换--协议转换模式提供多个有NAT-PT前缀的IPv6地址和一个源IPv4地址间的多对一动态映射。这种转换同时在第三层（IPv4/IPv6）和上层（TCP/UDP）进行。NAPT-PT和IPv4中的PAT转换类似。

   其他ipv6转ipv4的方式有：

   1. 双协议栈技术

      双协议栈技术是指在路由器或者主机上同时运行IPv4和IPv6协议。

   2. **隧道技术**

      目前常见的IPv6隧道传输方案有手工隧道与自动隧道，例如6 over 4、6 to 4等。其中自动隧道因为需要同时配置IPv4和IPv6地址，所以需要双协议栈路由器支持。**隧道技术是指将IPv6的数据包封装在IPv4的数据包里进行发送**，它好处就是不需要对现有的IPv4网络进行改造，就可以直接利用隧道来传输IPv6的数据包。隧道技术主要是为了向IPv6网络过渡过程中减少搭建设备的成本，但是它依然无法解决纯IPv4主机与IPv6主机的互通问题。







10. 哪些协议是基于TCP，哪些是基于UDP？
    1. 基于TCP：HTTP,FTP,SMTP,TELNET,POP3,Finger,NNTP,IMAP4；
    2. 基于UDP：BOOTP,DHCP,NTP,TFTP,SNMP；
    3. **DNS可以基于TCP，也可以基于UDP**；





11. 简答题：安全系统设计，第三方APP接入银行，银行APP可以直接使用第三方服务，如何保证系统安全和数据安全。

    参考https://blog.csdn.net/laibowon/article/details/78214396

    ①使用sharedPreference存储数据时，需要将sharedPreference设置为MODE_PRIVATE，防止别的进程查看数据；

    ②网络传输使用HTTPS代替HTTP，数据传输的时候进行加密保障安全；

    ③app加固，防止app被逆向分析,反编译,二次打包；

    ④防止界面劫持，启动一个service，在页面创建的时候判断该页面的包名和栈顶页面的包名是否一致，不一致则可能遭到页面劫持；

12. 简答题2：两个独立应用系统A和B，由于业务要求，A想要获得B数据库中的交易数据且不能直接访问B的数据库。

    1. 写出A访问B的交易数据的三种实现方式？

       方案一、系统A本地没有数据库，系统A中记录全部通过WebService接口形式，从B数据库中查询获得；

       方案二、系统A本地建立数据库A，数据库A与数据库B同步，实现读写分离；

       方案三、系统A本地建立数据库，初始时数据从B数据库中导入，之后B数据库中有更新，将更新的数据通过WebService方式，发送到系统A的值守程序，更新到数据库A中；

    2. B向A发送数据时出现发送超时，问B应该如何做。

       发送超时可能的原因是网络拥塞，数据量过大，A没有及时反馈等。可以采用将数据划分之后再传输，接收方A要及时返回ACK；

    3. A要对交易数据进行查询，如何提高A的查询速度。

       ①肯定是尽量使用索引，避免无法使用索引的情况；

       ②读写分离，避免由于更新表的时候表被加锁；

       ③SQL编写不合理，导致存在冗余的查询；





13. SQL的书写：

    1. 创建一个表：

       ```sql
       creat table `user` (
        `id` int(10) NOT NULL AUTO_INCREMENT,
        `phone` char(11) NOT NULL,
        `username` char(20) NOT NULL DEFAULT '',
        `password` char(32) NOT NULL DEFAULT '',
        `logintime` int(10) unsigned NOT NULL DEFAULT '0',
        `loginip` char(20) NOT NULL DEFAULT '',
        PRIMARY KEY (`id`),
        UNIQUE KEY `username` (`username`),--该唯一索引名为username
        KEY `phone` (`phone`)
       ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8
       ```

    2. 增加一列同时增加一个索引：

       ```sql
       alter table `user` add `phone` CHAR(11) NOT NULL DEFAULT '' AFTER `id`, ADD INDEX `phone` (`phone`);--插入新的一列在id后面，即AFTER `id`
       ```

    3. 删除一个表和删除一列：

       ```sql
       alter table 'user' drop 'phone'
       drop table 'user'
       ```

    4. 修改某一列的属性：

       ```sql
       alter table `user` change `username` `name` CHAR(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '';
       ```

    5. 显示这些列的属性：

       ```sql
       show COLUMNS FROM user;
       其等价于
       describe user; (简写为 desc user;)
       ```

       