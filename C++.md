## C++基础

1. cout和endl等有特殊含义的特殊符号称为**控制符**。
2. 想让函数访问名称空间std的方法：
   1. using namespace std放在函数定义之前，让文件中所有函数能够使用名称空间std中所有元素；
   2. using namespace std放在函数定义之内，让该函数可以使用std中的所有元素；
   3. 在特定函数中使用using std::cout这样的指令；
   4. 完全不用using，在需要的时候用作用域解析符std::cout；



## 数据处理

1. **char一般为8位--1字节；short一般为16位--2字节；int和float一般为32位--4字节；long和double一般为64位--8字节。**
2. const关键字修饰变量声明和初始化后，**编译器不允许再修改其值。**
3. C++11中可以使用auto关键字**根据初始值的类型判断变量的类型。**



## 复合类型

1. **cin使用空格、制表符和换行符确定结束位置。**

2. **共用体union**

   是一种数据形式，能够存储不同的数据类型，但是**只能同时存储其中的一种类型。其长度为其最大成员的长度。**

3. **枚举enum**，是一种快速创建符号常量的方式。第一个初始值默认为0，后面的元素默认比前面要大，所以enum bits{one=1，two，hundred=100，third}中，two=2，third=101.

4. 指针的大小与指向的类型无关，**与CPU、操作系统、编译器的位数有关，取其中最小的那一个值。一般地址就是32位--4字节的，所以即使指向很大的类，指针大小还是4字节。**

5. new分配内存的位置在堆中。

6. **内存泄漏：是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。**解决方法：**使用智能指针。**

7. 一般数组的名字就是指向第一个元素的地址，比如a[5]，那么a就是指向a[0]的指针；同时，a[3]==*（a+3）。

8. **动态联编和静态联编**

   1. 使用数组声明来创建数组时，将采用**静态联编，**即数组的长度**在编译时设置。**

      例如：int a[10];

   2. 使用new[]运算符来创建数组时，将采用**动态联编，**即数组的空间**在运行时分配。**

      例如：int size；

      ​			cin>>size;

      ​			int *p=new int[size];

   3. cout用于指针会输出地址，用于char*会输出其指向的那个字符串，要是需要输出地址，**必须强制类型转换为int\***。

   4. C++管理内存的3种方式：

      1. **自动存储**

         定义于**函数内部**的**常规变量**使用自动存储空间，通常存储在**栈**中，作用域为整个函数，生命周期与函数相同，离开代码块时，**按相反顺序释放，称为LIFO。**

      2. **静态存储**

         定义于**函数外部**或者**使用static关键字**的变量，通常存储在**静态存储区**，作用域为整个程序（static只是生命周期变了，作用范围不变），生命周期与程序相同。

      3. **动态存储**

         用new和delete配置的内存存在于**堆**中，其实就是一个**内存池**。作用范围要看具体使用犯法，声明周期由程序员控制。

      4. **线程存储--C++11限定**

         使用关键字thread_local声明的变量，其生命周期与所属线程相同。

   5. vector和array

      1. vector是一种**动态数组，使用new和delete来管理内存**。vector功能强大但是效率稍低；
      2. array和数组一样，**使用栈（静态内存分配，不是静态存储区域）**。其长度声明时固定：array<int,5> a;
      3. array和数组的两个小区别：①可以将array对象赋予另一个array对象，而数组只能逐元素复制；②array可以使用成员函数at()检查是否越界，数组不能；例如a.at(1)=3,即a[1]=3;如果非法会中断。



## 循环和关系表达式

1. C++将赋值表达式的值定义为左侧成员的值，例如：a=(b=4)+3，其中b=4的值为4，所以a的值为4+3=7；
2. C++11的新增循环：for（auto x:array），array是一个数组，x是其中的元素。



## 分支语句和逻辑运算符

1. ch++和ch+1的小区别：ch++是**重载运算符**，所以其类型没有变化；ch+1是**+运算，如果ch是char类型，那么其结果会上升为int。**
2. 逻辑运算符优先级：！（not）>关系运算符（大于小于等于）>&&（与）>||（或）
3. switch（a）中的a必须是**整数值**，常用int和char；与if else对比，选项超过2个，switch效率更高



## 函数

1. 函数的return只能返回对应类型或者能强制类型转换为对应类型的结果。
2. **通常，函数通过将返回值复制到指定的CPU寄存器或内存单元中将其返回。**
3. **const int *p**声明指出，p指向一个const int类型的变量，因此**不能通过p来修改他的值，但是可以直接修改他的值。但是可以用p指向别的const int类型变量**，此外，不能将const地址赋予非const指针。
4. **int * cosnt p**声明指出，const p指向一个int类型的变量，**因此p只能指向这个对象，但是可以修改他的值。**
5. 函数指针，最简单的方法，如果一个函数为int func（int）；那么对应的函数指针就是int （*f）（int），将func换为（\*f）。func（5）相当于（\*f）（5）。



## 函数探幽

1. **内联函数**：目的是提高程序的运行速度

   1. **常规函数中**，当执行到函数的时候，需要跳跃到函数开始的地址，然后开始执行函数，执行完毕以后要跳会函数调用的那里继续执行原函数，跳跃有一定的开销；
   2. **内联函数中**，编译器将使用相应的函数代码替换函数调用，因此无需跳跃到函数开始的资质。因此，在不同地方调用同一个内联函数，**将包含多个该内联函数的副本，占用内存空间。**
   3. 要使用内联函数，需要在**函数声明和函数定义前加上关键字inline**，并且内联函数**不能递归**。

2. 引用必须在初始化的时候就进行初始化，跟const一样，跟指针不一样。

3. 如果**函数的返回值是引用**，那么可以作为左值用于赋值。例如：func（a）=10；

4. 在函数原型中可以给参数赋默认值，**所有有默认值的参数必须在所有无默认值的参数的右边。**

5. 函数重载的关键是**函数特征标（即参数列表）。**函数重载的条件是**特征标不同**，即参数数目和类型、参数的排列顺序必须有所不同。如果没有完全匹配的函数，编译器会通过**合法的强制类型转换**去寻找最佳匹配，如果有**多个重载函数可用**，则报错。

6. **编译器如何跟踪重载函数？**编译器编译的时候，会对函数名进行**名称修饰或名称矫正**，将参数名和参数列表转换成内部表示，例如long func（int，float）会转换为？func@@YAXH，修饰方法以具体编译器而定。如果不想让编译器做这样的转换，可以利用**extern “c“**，强制编译器使用C风格的函数名编译。

7. 使用**函数模板**的时候，最终编译完成后程序不包含任何模板函数，而是根据具体条件**多个独立的函数，因此并不能通过函数模板来节省内存空间。**

8. **函数模板的显式具体化**：当编译器找到与函数调用最匹配的具体化定义的时候，就不会再使用模板。显式具体化的形式如下：

   模板：template<class T>

   ​			void swap(T &a,T &b);

   具体化：template<> void swap(job &,job &);

   具体化的模板也需要声明，编译器调用函数的**优先级：常规函数>具体化模板函数>模板函数**

9. **函数模板的显式实例化**：当编译器利用模板生成一个函数的时候，就是隐式实例化，这在遇到对应的函数调用的时候才会进行；显式实例化就是指明让编译器生成某种类型的函数实例，而不管是否有函数调用。

   模板：template<class T>

   ​			void swap(T &a,T &b);

   显式实例化：template void swap<job>(job &,job &);

10. **编译器如何选择使用哪个函数？**①创建候选函数列表，包含与被调用函数**名称相同的函数和模板函数**；②创建可行函数列表，**只考虑特征标不考虑返回值**，找到那些参数数目正确，或者可以通过强制类型转换变为正确的函数；③按照**完全匹配>提升转换（short、char转换为int）>标准转换（int转换为float，int转换为short）>用户定义的转换**的顺序选择调用函数，如果有多个函数都优先度相同，那就报错。

11. 关键字**decltype**：作用是返回参数的类型，参数如果可以是表达式或函数，如果是函数，则类型与函数返回值相同**（没有调用函数，就是查看函数原型的返回值）**。

    例如：int x=5；

    ​			decltype(x) y=10;

    在这里y的类型与x完全相同。

12. 与匿名函数类似，可以通过->来表示返回类型。

    例如template <class T>

    ​		auto gt(T x,T, y) -> decltype(x+y)

    ​		{

    ​			return x+y;

    ​		}



## 内存模型与名称空间

1. include中使用尖括号<>则编译器会到标准头文件的文件系统中取查找，如果是双引号“ ”则在当前工作目录开始查找。

2. 如果在同目前函数内，有多个**同名变量**，则会使用最新的定义，称为**新定义将隐藏旧定义**。

3. 调用函数的时候，记录**当时的**栈顶指针地址，首先将**参数列表**的自动变量压入栈中，然后后续的自动变量逐一入栈；当函数执行完毕以后，栈顶指针**恢复到函数调用开始的地方，并没有删除栈中的值，下次有自动变量会自动覆盖。**

4. 静态变量的**链接性**：

   1. 外部链接性：可在其他文件访问。需要在代码块外面声明；
   2. 内部链接性：只能在当前文件访问。需要在代码块外面声明，并且加上static关键字；
   3. 无链接性：自动变量属于无连接性。在代码块内部声明的变量，并加上static关键字；

5. **如何在多个文件中使用外部变量？**①只能在**一个文件中定义变量，单定义原则**；②其他使用这个变量的文件需要extern关键字引用声明；**注意：extren int a是声明，extern int a = 1是定义，跟int a = 1一样。**外部变量一样可以**被隐藏**（仅限链接性为内部的变量，如果声明了一个同名且链接性为外部的变量则违反单定义原则。）。

6. 作用域解析符“ :: "：利用作用域解析符，将使用变量的**全局版本**。例如”::a“就是在使用全局变量。

7. 无链接性的静态变量：如果一个static变量不是全局的，那么作用域不变，但是生命周期与程序一样，**在两次的函数调用之间，其值将保持不变。**

8. **关键字volatile**：此关键字表明即使没有对内存单元进行修改，其值也可能发生了变化。用volatile声明的变量每次都会从内存单元读取其值，而不是从缓存中读取。

9. **关键字mutable**：此关键字表明即使定义了一个const的该变量，也可以进行修改。

10. **const和static修饰全局变量的区别：**const会将全局变量的链接性变为内部，行为跟static一样。但是const可以用extern覆盖其内部链接性，在一个文件中定义extern const int a =2；在别的文件中声明extern const int a；来使用外部变量。

11. 在函数的声明和定义前同时使用static可以达到一样的内部连接性效果。

12. **定位new运算符**：new通常会在堆中寻找内存分配，但是也可以指定分配的内存地址：

    例如：

    char buf[1024]；

    int *p = new （buf） int[10]；

    就会从buf里分配内存。**注意，这个new是重载的，其分配的内存跟括号内有关，如果buf是静态存储区，就不能用delete来释放内存；如果这个buf是堆上面的，就可以用delete来释放。**



## 对象和类

1. OOP的三大特性：**封装、继承、多态。**
   1. 封装：数据隐藏、将实现细节与接口分开都被称为封装；
   2. 继承：继承分为公有继承、私有继承和保护集成；
   3. 多态：使用虚函数在派生类中重新定义基类的方法；
2. 类与结构的区别：它们之间唯一的区别就是类默认的访问类型为private，而结构的默认访问类型为public。
3. 类中的内联函数：其**定义位于声明中的函数**（一般在头文件里）将自动成为内联函数。
4. 不同的类有存储自己成员变量的内存空间，但是其成员函数是共享的。
5. 构造函数：与类同名的成员函数。如果没有实现构造函数，则系统会自动生成默认构造函数。
6. 析构函数：在类名前加~的成员函数，**析构函数没有参数也没有返回类型。**如果没有实现析构函数，则系统会自动生成默认析构函数。
7. const后置于成员函数：这种方式的声明和定义的成员函数表明**此方法不会修改调用对象。**
8. this指针：this指针指向调用成员函数的对象，*this表示对象本身。



## 使用类

1. 运算符重载：C++允许对运算符进行重载，**但是必须是有效的C++运算符，不能是新的符号。**方法为：

   void operator+（int &a）即重载+运算符，其他符号同理。

   **限制：**

   1. 重载后的运算符必须至少有一个操作数是用户定义的类型；

   2. 使用方法不能违反原来的句法规则；

   3. 不能创造新的运算符；

   4. **无法重载**：

      sizeof；

      . （成员访问运算符）；

      .*（成员指针访问运算符） ；

      ::（作用域运算符） ；

      ?:  （条件运算符）；

      typeid（RTTI运算符）；

      const_cast（强制类型转换运算符）；

      dynamic_cast（强制类型转换运算符）；

      reinterpret_cast（强制类型转换运算符）；

      static_cast（强制类型转换运算符）；

   5. **下面的运算符只能通过成员函数重载**：

      = （赋值运算符）；

      （） （函数调用运算符）；

      [] （下标运算符）；

      ->（指针访问运算符）；

2. 友元函数：通过让函数成为友元，可以赋予其与类成员函数一样的访问权限。

   1. 创建友元的第一步是将原型放在类声明当中，同时**加上friend关键字**：

      friend T operator*（double ，T）；

   2. **友元函数不是成员函数，定义函数时无须加上作用域解析符。定义时无须加上friend。**

   3. 友元访问共有的成员变量**需要加作用域解析符。**

3. 关键字explicit：用于关闭隐式转换，但仍然允许显式转换。例如：

   class A{int a；A（int x）{}；}

   A a1 = 5；//隐式类型转换，将先生成一个临时对象，然后赋值给a1

   **如果一个构造函数只含有唯一一个参数，将此参数的类型赋予类对象的时候将自动调用。**

   如果使用了explicit：

   class A{int a；explicit A（int x）{}；}

   A a1 = 5；//报错

   A a1 = A（5）//允许

4. **显式指定类型转换函数**：用于将类对象转换为对应的类型，转换函数**必须是类方法；不能指定返回类型且没有参数；**例如，将类T转换为double的转换函数为

   operator double （）；



## 类和动态内存分配

1. static变量只有一个副本，即所有的对象**共享一个静态成员。**但是**不能在类声明中初始化静态成员变量，因为声明只描述了如何分配内存，并不分配内存（有一个例外，如果静态成员是const整数类型或者枚举型，可以在类声明中初始化）。**对于静态成员，需要在**类声明以外**用单独的语句初始化，因为静态成员是**单独存储的，不是对象的组成部分。**初始化的时候**需要使用作用域解析符，但是不需要static。**

2. C++自动提供下面的成员函数：

   1. 默认构造函数
   2. 默认析构函数
   3. 复制构造函数
   4. 赋值运算符
   5. 移动复制构造函数（C++11）
   6. 移动赋值运算符（C++11）

3. 默认的复制构造函数逐个复制非静态成员（**浅复制**），复制成员的值。**如果对象中含有指针，那么默认的复制不会复制指向的内存，而是复制了一个指针。**此时两个指针指向同一个地址，当第一个对象析构之后，复制的对象指针就无意义了。

4. 与之相对的，**深复制**是复制指向的数据，而不是指针。

5. 在C++中，可以用nullptr表示空指针，比用0表示更容易理解。

6. 对于**[]运算符重载**，一般会有两个类似的成员函数：

   char & operator\[\]\(const char &s \)

   char operator\[\]\(const char &s \)

   其区别在于，第一个成员函数用于左值，可以对特定的元素赋值，第二个只能作为右值返回元素。

7. **静态成员函数**：成员函数声明包含static关键字。①首先，不能通过对象调用静态成员函数，也不能使用this指针，在公有部分声明的可以用作用域解析符；②由于静态成员函数不属于特定的对象，所以只能访问静态成员变量。

8. 返回const引用**可以提高效率**，因为这种做法**返回引用避免了隐式调用复制构造函数**。

9. 对于const和引用成员变量，所以只能对其进行初始化而不能赋值。因此必须在构造函数开始之前定义完毕，因此使用**成员初始化列表，此方法只能用于构造函数。**例如：

   Queue::Queue（int qs）：qsize（qs）{}



## 类继承

1. **公有派生**：class A：public B表示A以B为基类进行公有派生得到的类。

   ①**基类的公有部分将成为派生类的公有部分**；

   ②**私有部分也将成为派生类的一部分，但是只能通过公有方法或保护方法访问**；

2. 创建派生类对象时，**首先会创建基类对象**，且要求在进入派生类构造函数之前创建，所以要用到**成员初始化列表**。

3. 基类与派生类的特殊关系：

   ①派生类可以使用基类的非私有方法；

   ②基类指针和基类引用可以**直接**指向或引用派生类对象（仅限公有继承，**保护、私有继承的时候，只能通过强制类型转换来用基类指针指向派生类对象。因为此时派生类只继承实现，没继承接口，所以严格上来说不算基类对象。**）；

   ③基类指针只能调用基类的方法，指向派生类对象也不能调用派生类对象的方法；

4. 关键字virtual：在方法前面加上virtual可以将方法设置为虚方法，该关键字只能用于函数声明，不能用于定义。如果方法没有声明为虚方法，则程序**将根据引用类型或指针类型选择方法**；如果声明为虚方法，**程序将根据引用或指向的对象的类型来选择方法。**一般基类需要一个虚的析构函数，目的是在析构派生类的时候析构函数的调用顺序是正确的。

5. 如果派生类重写了基类的方法，此时要调用基类的方法，则应该**使用作用域解析符**；如果派生类没有重写该方法，则不需要用作用域解析符。

6. **静态联编和动态联编**：如果成员函数**不是虚函数，则使用静态联编。**因为调用该方法的指针类型在编译前已知；如果成员函数**是虚函数，则使用动态联编。**因为选择哪个方法是根据调用此方法的对象的类型，与指针或引用无关，所以在执行时才知道调用哪一个。

7. 为何需要两种联编，为什么静态联编是默认值？**因为静态联编的效率更高和概念模型更好，这正是C++的设计指导原则之一：不要为不使用的特性付出代价。**如果全部使用动态联编，那么必须采取一些方法去跟踪调用函数的对象类型，这是一种开销；此外，如果类不用作基类，或者基类的方法没有声明为虚的，那说明不需要使用动态联编，此时静态联编更高。**在概念模型上，声明为虚函数也就是期望被重写的方法，其他函数不希望被重写。**

8. **虚函数的实现原理**：编译器给**每个对象**添加了一个隐藏的成员指针，指向**虚函数表**，表中存储了为类对象进行声明的虚函数的地址。例如，基类有一个虚函数表的指针，里面是基类所有虚函数的地址；派生类会有一个**独立的虚函数表的指针**，如果重写了该方法，或者新增了一些虚方法，那么就会与基类不同，而继承自基类的没有重写的虚方法，则地址与基类一样。**每次调用虚函数的时候，都必须取虚函数表那里查找，增加了开销。**

9. 构造函数、友元函数**不能**是虚函数，析构函数**应当**是虚函数。

10. 重定义与重载：重定义是在**派生类中重写基类的方法**；重载是在**一个类**里面有多个同名的方法。注意，如果基类有多个重载函数，派生类重写了其中一个，**剩余的重载函数将被隐藏而无法调用**。

11. protected保护继承：对于派生类而言，**保护继承与公有继承没有区别**，对于外部世界，**保护继承相当于私有继承。**

12. 纯虚函数：函数原型的后面包含“= 0”的函数称为纯虚函数。**包含纯虚函数的类不能创建对象。**

13. 什么无法继承？**构造函数、析构函数、赋值运算符、友元函数**都是不能继承的。友元函数由于不是成员函数，当然不能继承；如果想要使用基类的友元，可以将派生类强制类型转换为基类然后调用基类的友元函数。



## C++中的代码重用

1. 对于继承的对象，构造函数在**初始化列表**中使用类名来调用特定的基类构造函数，但是初始化的顺序与列表中的顺序无关，只与类声明中他们定义的顺序有关。

2. 私有继承：基类的公有成员和保护成员都会成为派生类的**私有成员**，即只继承实现不继承接口。因此，**私有继承与包含相同。**但有几点不同：

   ①包含提供显式命名的对象成员，但是私有继承提供的是匿名的对象成员；

   ②在构造函数的初始化列表中，使用类名而不是对象名进行初始化；

   ③包含可以包含多个同类对象，私有继承只能包含一个同类对象；

   ④包含不能进行函数重载；

3. 在私有继承中，**只能在派生类的方法中使用基类的方法，且需要使用作用域解析符。**例如，A私有继承于B，想调用B的方法b1，则需要在A的方法a1中使用B::b1。

4. 想要访问私有继承的基类的内部对象，可以使用**强制类型转换**。例如，A私有继承于B，想访问B的变量b1，则需要在A的方法a1中使用（const B &）\*this。

5. 保护继承：基类的公有成员和保护成员都将变为派生类的**保护成员**，私有成员不变。

6. 虚基类：虚基类使得**多个基类相同的类**在使用多重继承的时候，派生出的对象值含有一个基类对象。使用方法是在公有继承的前面加上virtual关键字。当使用虚基类的时候，C++禁止使用中间类传递信息给基类，因此在**初始化列表中必须显式调用基类的构造函数，**传入中间类的信息不会用于构建基类，**对于虚基类必须这么做，对于非虚基类则非法。**

7. 在多重继承中，如果A继承自BC，BC中都实现了f方法，如果A直接调用f会非法，必须使用**作用域解析符**表明调用的函数。

8. 模板类：模板不是函数，**所以不能单独编译，必须与特定的模板实例化请求一起使用（实际上可以内联或者直接头文件声明）。**此外，作用域解析符有一些不同，对于template<class T>class S的一个类，作用域解析符为S<T>:: 。

9. 可以为**类模板的类型参数**提供默认值，但是不能为**函数模板**提供默认值。即可以使用template<class T = int>。

10. 模板类的显式实例化：与模板函数类似，可以显式指定编译器生成使用何种类型的模板类，而不是等到调用这个类。例如：

    template<class T>

    class A{}

    可以改为template class A<int>;

11. 模板类的显式具体化：与模板函数类似，可以显式指定需要何种类型的模板类。例如

    template <> calss A <int>

    模板类还可以**部分具体化**，即只对部分模板类型参数赋予默认值。例如：

    template<class T1,class T2> class A{};

    可以改为

    template<class T1> class A<T1,int>{};




## 友元、异常和其他

1. 友元类：如果在类A中声明friend class B，则**B可以访问A的私有部分**。如果只是将类B的某个函数声明为A的友元，那只有这个函数可以访问A的私有部分。

2. 如果A类对象的方法使用了B类对象，则其原型可以在B类对象的声明之前，**但是其实现必须在B类对象声明之后。**因为编译器遇到此方法的时候并不知道B类对象和B类对象有什么方法，所以要等编译器有足够信息才可以编译。

3. 嵌套类：嵌套类的**作用域是包含他的类。**如果是在**私有部分**声明的，那就只能在这个类里面使用这个嵌套类，继承或者外部都无法使用嵌套类；如果嵌套类是**公有部分**声明的，那么继承或者外部都可以使用，但是外部需要**两层的作用域解析符**；如果是在**保护部分**声明的，那么继承可以使用，但是外部不可使用。

4. 处理异常的方法：

   ①调用abort（）：函数原型位于<cstdlib>，调用abort会向标准错误流cerr发送abnormal program terminal（程序异常终止），**然后终止程序**（或者返回父进程，但是不会返回到调用函数）。

   ②**关键字throw实际上是跳转，表示引发异常，可以携带错误信息。**

   ​	例如：if（a==0） throw ”a is zero.“；

   ​	throw不会将控制权返回给调用程序，而是沿着调用栈一直返回直到找到try块,**此过程称为栈解退，栈解退过程中的类对象会调用析构函数**。

   ③**关键字catch捕捉异常，其参数表示要响应的类型。**

   ​	例如：catch（const char *）{}这就捕捉了上面的异常。

   ④**try块标识可能会引发特定异常的代码块，其后有若干个catch块。**
   
   ⑤如果**没有匹配的catch，会一直返回直到找到匹配的catch，如果一直没有就终止程序。**
   
   ⑥在catch中使用“throw；”语句会将异常往回送。
   
   ⑦catch成功执行之后会执行catch块后面的语句继续执行。
   
   ⑧如果要捕捉**任何异常**，方法是使用省略号作为catch的参数。catch（...）{}
   
   ⑨如果引发的异常有可能是派生类或者基类，那么catch的最上方应该是继承最底层的派生类，**最后一个catch才是基类。**
   
5. try-catch与普通函数的区别：

   ①函数结束后控制权返回**调用它的函数**，而**异常返回到上一个try-catch块。**

   ②引发异常时，编译器总会创建一个拷贝。即即使catch的参数是一个引用，依然会是一个副本，**好处是，栈解退的时候可能那个对象不存在了，所以要拷贝一个。**

6. **exception类**：其位于头文件<exception>，里面有一个虚拟成员函数what（），可以对其重写来定制行为。例如：

   class A：public std::exception

   {

   public：

   ​	const char* what（）{ “ bad alloc.” ；}

   }

   然后捕捉到异常就可以：

   cout<<e.what()<<endl;

7. **stdexcep类**：该文件定义了两个从exception共有派生得到的logic_error和runtime_error类，从logic_error中派生出**domain_error、invalid_error、length_error、out_of_bounds**，捕捉到的异常分别代表**参数不在定义域内、参数类型错误、空间不足、索引错误引发的异常。**

8. new和bad_alloc异常：**bad_alloc异常是从exception公有派生而来的异常类**，正常实现是显示what信息后exit终止程序。**有一种返回空指针的new，**如：

   int * p = new（std::nothrow） int；

   则失败的时候会返回空指针， p == 0 为true。

9. 如果引发了异常**但是没有被捕捉**，程序会先调用**terminate（）**，其默认行为是调用abort然后终止程序，所以可以**通过set_terminate（）**定制terminate来改变其行为。**与set_new_handler一样，其接受一个函数指针，这个函数没有参数也没有返回值。**

10. **RTTI（runtime type identification）运行阶段类型识别。**旨在为程序在运行阶段**确定对象的类型**提供一种标准方式。

    C++有三个支持RTTI的元素：**dynamic_cast、typeid、type.info。**

    **注意：RTTI只能用于包含虚函数的层次结构，因为只有这种结构才会存在基类指针指向派生类。**下面详细介绍RTTI的三个元素：

    1. dynamic_cast

       用法：

       T* p = dynamic_cast<T*>（pt）

       返回值：

       **如果pt指向的类型可以安全地转换为T，那就返回对象的地址，否则返回空指针。**

       （一般都是将派生类指针pt转换为基类指针p）

       也可以用于引用的类型转换，但是引用没有与空指针对应的特殊返回值，所以**请求不正确的时候会返回bad_cast异常。**

    2. typeid可以接受**类名或者返回值是对象的表达式**，然后返回一个**对type_info的引用。**

       因此可以通过typeid（A）==typeid（*p）来判断p指向的类型是否为A，是返回true。如果p是空指针，就**引发bad_typeid异常。**在type_info里面包含一个name()成员，该函数返回一个随实现而异的字符串。如果能用dynamic_cast的话尽量用，因为比typeid比较更加简洁。

    3. 一共有四种类型转换：**dynamic_cast、const_cast、static_cast、reinterpret_cast。**

    4. **const_cast**用于执行只有一种用途的类型转换，改变const或volatile。

       如果一个指针pt类型为const A*，他指向一个对象A a1，如果调用

       A \*pt = const_cast<A\*>（pt），那么pt就可用于修改a1的值了，**如果a1的类型本身就是const的，那这个转换无效，因为A\*的指针不能指向const A\*，反之可以。**

    5. **static_cast：用法与上述类似。仅当尖括号里的类和指针指向的类可以通过隐式转换的时候，才是合法的。**例如，类A是类B的基类，类C是无关的类，那么A和B相互转换是合法的，但是A和C或者B和C都是不合法的**（虽然基类转换为派生类指针必须显式转换，但是反过来可以隐式转换，那就是合法的）**。

    6. **reinterpret_cast：用于天生危险的类型转换，不能用于删除const。主要就是进行一些合法的转换，不合法的不行。**



## string类和标准模板库STL

1. **STL的编程模式是泛型编程，等下会详细介绍。**string也不例外，其实string类是一个模板类，string是由basci_string<char>进行typedef得到的一个具体化。

2. string**可以自动调整目标string的对象的大小，限制string类对象的最大长度的是一个string类里面的静态成员变量string::npos。**

3. 使用getline（cin，string）可以不用指定string的长度，因为会自动调整。**底层实现：一开始string有一个初始大小k，如果字符串不断增大，则会将string的大小翻倍变成2k，以提供足够的空间。**使用capacity（）查看当前string占用的内存块大小。

4. **智能指针模板类（RAII->资源获取时即初始化）：**

   头文件<memory>

   智能指针是**行为类似于指针**的**类对象**。主要是为了解决动态内存分配new之后可能会导致的内存泄漏。智能指针在过期的时候**会让指向的对象调用析构函数，然后自身再调用析构函数，保证释放内存。**

   注意：**只有通过动态内存分配new获得的地址赋予这三种智能指针，如果是new[]的只能赋予unique_ptr。智能指针不允许常规指针隐式转换为智能指针，但是反过来可以，同类型的智能指针也可以。**

   1. auto_ptr

      用法形如：auto_ptr<string> ps（new string）。auto_ptr指针**独占对象的所有权**，如果将其赋予其他的智能指针，再次访问这个auto_ptr的时候会程序终止。

   2. unique_ptr

      与auto_ptr类似，但是对于对象的独占更加严格。**如果有语句使得unique指针失去对象所有权，那么这个程序无法通过编译。**但是有一个例外，如果unique指向一个**临时右值**，那么会夺取此对象所有权，然后临时右值消失。

   3. shared_ptr

      shared指针用于多个指针指向同一对象的情况。当shared指针指向一个对象的时候，**其内部有一个计数器，**当有另一个shared指针指向同一个对象的时候计数+1，如果某个指针失效了，计数-1，直到计数为0的时候调用对象的析构函数释放内存。**另外，shared有一个显式构造函数用于将右值unique转换为shared，注意一样要显式调用。**

5. 在STL中，迭代器是一个广义指针，用于STL容易的迭代。可以通过下列方法将容易内的元素作用于指向的函数

   for_each（v.begin（），v.end（），func）

   begin和end是迭代器，区间为**左闭右开**，func是函数描述符，也可以是**重载了operator()**的类对象，**for_each不能修改容器里的元素。**在C++11中有一个新的循环体for（auto x：v），其中v是一个容器，x是容器中的元素，**这种for循环可以修改容器元素，但是需要使用引用，即for（auto &x：v）。**

6. **泛型编程旨在编写独立于数据类型的代码，完成泛型编程的工具是模板。对于++i，C++使用operator++（）作为重载操作符函数；对于i++，用operator++（int）重载，这个int不会用到，所以不用指定名称。**

7. 5种迭代器类型：

   1. 输入迭代器

      用来**读取**容器中的元素，**每次访问元素的顺序是不同的，并且只能前进不能后退。**

   2. 输出迭代器

      用来**修改**容器中的元素**，每次访问元素的顺序是不同的**。

   3. 正向迭代器

      **每次访问元素的顺序相同，可读可写。**

   4. 双向迭代器

      正向迭代器的升级版本，支持双向遍历。

   5. 随机访问迭代器

      除了双向迭代器的所有特性，还能**随机访问**，还支持用于排序的关系运算符。

8. **set、map、multiset、multimap都是关联容器，都是基于树结构的；如果是unordered版本，都是无序关联容器，都是基于哈希表的。**



## 输入、输出和文件

1. 先不看了，有空再说



## 探讨C++11新标准

1. 模板别名using：跟typedef一样的作用，但是**using可用于模板部分具体化，typedef不能。**

   typedef A B，B是A的一个别名，等价于using B=A；

   但是using可用于：

   template<typename T>

   using arr12 = std::array<T,12>;

   那我们可以定义arr12<double>等价于std::array<double,12>。

2. **C++11的右值引用**：左值可以出现在赋值语句的左边或者右边，右值**只能出现在右边**。

   右值引用使用&&表示，例如常量18，'a'，或者表达式的计算结果x+y，函数的返回结果等这些临时性的或者不可修改的都是右值。**引入右值引用的主要目的之一是实现移动语义。移动语义是为了减少不必要的复制开销，即原数据还留在源地址，只是所有权改变了。**

3. **复制构造函数执行深复刻，移动构造函数只调整记录，但是所有权转移的过程中可能修改实参，所以右值引用不应该是const（比如定义的右值引用构造函数将右值对象的成员变量归零等）。**同时也是一个区分移动构造函数和复制构造函数，移动赋值运算符和赋值运算符，**无const的就是移动语义的。**

4. 强制使用右值引用：

   ①使用static_cast强制转换为右值引用类型；

   ②**使用std::move（）函数**；move（A）使得A变成一个右值，但是**并不一定会导致移动操作。**如果定义了移动赋值运算符，就会调用；如果没有定义，**将调用复制赋值运算符**；如果还是没有，**不允许上述赋值。**

5. C++11对类默认提供：默认构造函数、默认析构函数、赋值运算符、移动赋值运算符、复制构造函数、移动构造函数。**如果提供了析构函数、复制构造函数或复制赋值运算符，将不会自动提供移动构造函数和移动赋值运算符；如果提供了移动构造函数或移动赋值运算符，将不会自动提供复制构造函数和复制赋值运算符。**

6. 默认方法：

   A（） = default ；

   编译器将提供A默认的构造函数，**但是只有6个特殊的成员函数可以用default。**

   禁用方法：

   A（） = delete；

   禁止编译器使用该方法，**该关键字可以用于任何成员函数。**

7. 委托构造函数：在构造函数的定义中调用另一个构造函数（一般就是在初始化列表），将构造的任务委托给别的构造函数完成。

8. 继承构造函数：如果B是A的派生类，在B中声明**using A::A**，则在**B中匹配不到对应的构造函数**的时候会去A中寻找匹配的构造函数。

9. **标识符**override和final，注意，这两个**不是关键字。**因此override和final只有在特定上下文的时候才有意义，别的时候可以用作变量名。在派生类的虚函数参数列表后面加override表示**重写基类中的同名方法**，这个时候如果与基类的同名方法的函数特征标不对应就会报错；在基类的**虚函数**后面加上final表示**禁止派生类重写该函数。**

10. **匿名函数**

    形如\[\]\(\){}的就是匿名函数

    ①**仅当**匿名函数**完全由一条返回语句**组成的时候，才可以使用自动类型推断来返回；否则需要**后置返回类型**；

    ②[a]表示**按值传递将变量a传入匿名函数**，[&a]表示**按引用**传递；\[=\]表示按值传递所有动态变量；[&\]表示按引用传递所有动态变量；可以混合使用\[=，&a\]这样。

11. **可变参数模板**

    可变参数模板用于创建接受**参数数量可变**的模板函数和模板类。

    template<typename... Args>

    void show（Args... args）

    Args是模板参数包，args是函数参数包。

    ①**不能**使用索引来随机访问参数；

    ②一般用法如下：

    template<typename T>

    void show（T val）

    template<typename T,typename... Args>

    void show（T val，Args... args）{show（val）；show（args...）；}

    **注意一个参数的模板必须放在上面；多参数的模板要传递args...；**

    





