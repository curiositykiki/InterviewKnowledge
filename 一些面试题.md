### new和malloc的区别

1. 都是在堆上面分配内存，但是malloc**不具备初始化功能**，new**具备初始化功能**（其实new的底层实现还是malloc，但是会使用**构造函数**来进行初始化）；
2. malloc是一个**函数**，参数为需要的字节数，返回值是**void\*无类型指针**，因此需要进行强制类型转换；new是**运算符**，只需要指定所需要的的内存的类型，就可以了返回指向指定类型的地址；
3. malloc分配内存失败会**返回空指针**，new分配内存失败会**返回bad_alloc异常**；
4. malloc分配的内存用free来释放，new对应delete，new[]对应delete[]；
5. malloc只有一种方式，但是new还有很多版本，比如new（nothrow）失败会返回空指针，const new，new（buffer）在指定的位置分配内存；
6. memcpy和realloc等函数都是进行**内存值的拷贝**，也就是说，如果是指针，那只是吧指针copy了，是一种**浅拷贝**；正确做法应该是调用构造函数创建新对象来进行**深拷贝**。



### 红黑树

1. 是一种**自平衡的二叉查找树**，同时不是完美的平衡二叉树，左右子树之差有可能超过1；

2. 性质：

   1. 根节点肯定是黑色的；
   2. 每个节点只能是红色或者黑色；
   3. 叶子节点（是指null）肯定是黑色的；
   4. 每个红色节点必然连接两个黑色节点；
   5. **任意一个节点到达每个叶子节点经过的黑色节点必然相等；**

3. 自平衡的操作：通过旋转和变色就可以了达到平衡。

   1. 左旋：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。（跟平衡二叉树的旋转一样）
   2. 右旋：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。
   3. 变色：结点的颜色由红变黑或由黑变红。

4. **红黑树查找**：跟二叉排序树一模一样，最坏时间复杂度为O（2logn），此时刚好此次查找路径**红黑相间**。

5. **红黑树插入**：首先查找插入的位置，然后进行自平衡。

   1. 新节点插入是初始颜色为**红色**，所以最关键的就看父节点是什么颜色；
   2. **父节点为黑色**，直接插入；
   3. **父节点为红色，叔叔节点也是红色，**则将父节点和叔叔节点**设置为黑色**，祖父节点设置为**红色**，然后把祖父节点当做插入来看待，继续自平衡；
   4. **父节点为红色，叔叔节点是黑色或者不存在，且父节点是祖父节点的左节点，**由于父节点是红色的所以祖父节点必然是黑色的，进行**右旋**，同时注意，旋转后**祖父节点那个位置的节点还是黑色**的，然后**祖父节点那个位置的两个子节点都是红色**的；
   5. **父节点为红色，叔叔节点是黑色或者不存在，且父节点是祖父节点的右节点，**与上述情况类似，这个时候与平衡二叉树的LR相似，所以**先左旋后右旋**，结果跟4差不多；

6. **红黑树的删除**：首先查找要删除的节点，然后进行自平衡。

   1. 删除的节点**无子节点**，直接删除；

   2. 删除的节点**有一个子节点**，用子节点**替换**删除的节点；

   3. 删除的节点**有两个子节点**，用其**后驱（中序遍历的下一个，就是右子树的左下角那个节点）节点替换**删除节点；

      加上颜色特征：

      1. 替换节点是**红色**，将替代节点的值复制过去删除节点，**替代节点换成删除节点的颜色，**然后**递归**检查那个替代节点；
      2. 替换节点是**黑色**，且是**父节点的左子节点**，兄弟节点是**红色的**，



### topK问题（非常重要！！！）

给定1亿个数字，找出前100大的数字。

使用**堆排序**来解决，维护一个100个元素的**小顶堆**，这个堆的顶端就是这个100个元素的最小值。因此，只要将剩余的数字逐个与堆顶比较，**如果比堆顶大则将堆顶替换，然后调整堆。**直到最后就会剩余100个最大的元素。边插入边调整堆，复杂度为O（KlogK），然后剩余的N-K个点最坏情况下每次都要插入调整堆，时间复杂度为O（（N-K）logK），综上，总体时间复杂度为O（NlogK）。

代码：

```
#include<bits/stdc++.h>
using namespace std;
void exchange(vector<int> &wh, vector<int> &h,int a, int b) {
	int temp = wh[a];
	wh[a] = h[b];
	h[b] = temp;
	return;
}
void fixheap(vector<int> &h) {
	int i = 1;
	while ((i*2) < h.size()) {
		int j = 2 * i;
		if ((j + 1) < h.size() && h[j + 1] < h[j])
			j++;
		if (h[i] < h[j])
			break;
		swap(h[i], h[j]);
		i = j;
	}
	return;
}
int main() {
	vector<int> wh{ 11,22,33,44,55,66,77,88,99,2,5,0,1,8,9,6,623 }, tempheap{0};
	int k = 5;
	for (int i = 0; i < k; ++i) {
		tempheap.push_back(wh[i]);
		fixheap(tempheap);
	}
	for(int i=k;i<wh.size();++i)
		if (wh[i] > tempheap[1]) {
			exchange(wh, tempheap,i,1);
			fixheap(tempheap);
		}
	for (int i = 1; i < k + 1; ++i)
		cout << tempheap[i] << endl;
	return 0;
}
```

### topK问题（这里以找到第K大的数为例）有没有其他更好的解法？

**思路**：利用**快速排序的思想**，如果要找到第K大的数字，可以先把数组以mid划分为两半，一半小于等于array[mid]，一半大于array[mid]。①如果K<mid，说明**要寻找的K在左边**，只需要在左边中查找就ok；②如果K>mid，说明**要寻找的K在右边**，注意，此时要在右边寻找时，**由于已经确定了mid前的都是小于K的，所以在右边寻找K-mid大的数字**；注意了，快速排序的时间复杂度为O（nlogn），是通过**master定理计算的**，递归的快速排序为T（n）=2T（n/2）+f（n），f（n）是找到那个数的位置，以这个数分成两个T（n/2）。此外，选取基准可以通过**三数取中**的方法，即取头尾中间三个数作比较，用大小为中间的数作为基准来划分。

**代码**

```
#include<bits/stdc++.h>
```

https://www.jianshu.com/p/e136ec79235c



### 内存对齐问题

为什么要考虑内存对齐问题？

可执行程序是由一系列CPU指令构成的，对于一些指令是需要访问内存的，且CPU不是按位读取内存的，而是按双字节。如果内存没有对齐，CPU取得数据时必须按照偏移量去读取所需要的的数据所谓的地址；如果对齐了内存，就可以直接获取所需要的的数据。虽然CPU本身就可以读取未对齐的内存，但是性能上有可能会收到影响；有些CPU甚至会抛出异常，而且对于别的一些平台可能不可移植。

那么内存对齐包含什么内容呢？

首先应该知道的是，**系统的默认对齐系数**：linux默认为#pragma pack（4），windows默认为#pragma pack（8）；没错，我们可以用#pragma pack（n）来指定对齐系数的大小；

第二，就是**偏移量**：简单来说，在32位操作系统中，32位代表8字节，所以每一块8字节里面需要一个offset偏移量来指定这个数据在这一块里面的那个地址开始，32位操作系统自然就是0~31；

第三，就是**三个原则**：

1. 结构体或者共用体中第一个数据的偏移量为0，此后的**偏移量必须是#pragma pack（n）指定的n和那个数据长度较小的那个的倍数**；
2. 结构体或者共同体内部数据对齐完毕后，**整个结构体和共同体也要对齐**。标准为#pragma pack（n）指定的n和**结构体和共同体内最长数据的长度**中较小的一个；
3. 如果结构体嵌套了，那就是套娃了。我们可以把嵌套的那个共同体当做一个成员，然后**先按照规则2求出来它的起始便宜量**，然后根据规则2计算整体偏移量，最后下一个元素再根据1来正常做对齐；

例子：

#pragma pack（4）

struct X{

​	int a；//长度4字节，与#pragma pack（n）比较，较小的是4，因此**偏移量应该是4的倍数**，这里是0，满足要求；所以a放在0~3这四位里面；

​	char b；//长度1字节，与#pragma pack（n）比较，较小的是1，因此**偏移量应该是1的倍数**，这里是4（**其实就是已经被人占用的长度**），满足要求；所以a放在4~4这一位里面；

​	short c；//长度2字节，与#pragma pack（n）比较，较小的是2，因此**偏移量应该是2的倍数**，这里是5，不满足要求，对齐为6；所以a放在6~7这两位里面；

​	char d；//长度1字节，与#pragma pack（n）比较，较小的是1，因此**偏移量应该是1的倍数**，这里是8，满足要求；所以a放在8~8这两位里面；

}

因为占用了0~8这9位，所以这个结构体的长度是9字节。首先计算整体对齐系数 =min （max（int，char，short）**（结构体内最长的那个结构）**，4**（由#pragma pack（n）指定）**） = min（4，4） = 4，因此应该是4的倍数，应该对齐为12，所以这个结构体要占12字节的空间。



#pragma pack（8）

struct X{

​	int a；//长度4字节，与#pragma pack（n）比较，较小的是4，因此**偏移量应该是4的倍数**，这里是0，满足要求；所以a放在0~3这四位里面；

​	char b；//长度1字节，与#pragma pack（n）比较，较小的是1，因此**偏移量应该是1的倍数**，这里是4，满足要求；所以a放在4~4这一位里面；

​	short c；//长度2字节，与#pragma pack（n）比较，较小的是2，因此**偏移量应该是2的倍数**，这里是5，不满足要求，对齐为6；所以a放在6~7这两位里面；

​	**//首先按照原则1计算，结构体Y内部最长是int = 4位，目前默认是8，因此偏移量应该是4的倍数，这里是8，满足要求；**

​	struct Y{

​		int a1；//长度4字节，与#pragma pack（n）比较，较小的是4，因此**偏移量应该是4的倍数**，这里是8，满足要求；所以a放在8~11这四位里面；

​		char b1；//长度1字节，与#pragma pack（n）比较，较小的是1，因此**偏移量应该是1的倍数**，这里是12，满足要求；所以a放在12~12这一位里面；

​		short c1；//长度2字节，与#pragma pack（n）比较，较小的是2，因此**偏移量应该是2的倍数**，这里是13，不满足要求，对齐为14；所以a放在14~15这两位里面；

​		char d1；//长度1字节，与#pragma pack（n）比较，较小的是1，因此**偏移量应该是1的倍数**，这里是16，满足要求；所以a放在16~16这一位里面；

​	}

**//结构体Y内部最长为int = 4位，默认为8位，因此偏移量应该是4的倍数，这里是17，不满足要求，对齐为20，下一个元素从21开始；**

​	char d；//长度1字节，与#pragma pack（n）比较，较小的是1，因此**偏移量应该是1的倍数**，这里是21，满足要求；所以a放在21~21这一位里面；

}

跟上述的计算类似，这里结构体X内最大的为int = 4（struct Y不算），默认为8，所以偏移量应该为4的倍数，这里是22，不满足要求，因此对齐为24；



### char\*和char[]的区别

1. char\*是一个指针定义，char[]是一个数组定义。数组是一块连续的内存，所以可以通过sizeof求得整个字符串的长度，除以每个字符的长度可以得到字符串的长度；但是sizeof用于char\*只能得到指针的长度，并不能取得字符串的长度；
2. 第二个就是**分配的内存位置不同**。如果有初始化，char\*分配的是在常数区域**（一般内存区域分为5块：栈（一些局部变量等等）、堆（动态分配的内存）、静态存储区域（全局变量和static变量）、常量存储区域、自由存储区域）**的内存，因此初始化之后不能修改字符串的值；char[]分配的是栈上面的内存，因此可以改变字符串内部的值；
3. 第三个就是**读写的权限不同**。数组定义的数组名可以当作指向一块连续内存开头的地址，可以认为是一个指针。**但是只能是一个常数指针**，因为char[]初始化之后不能指向别的字符串，但是char\*可以指向别的数组；
4. 第四个就是**赋值的时刻不同**。因为指针定义指向一个常量字符串，所以**编译**的时候就已经分配了；数组定义的分配是需要等到**运行**时才会分配；
5. 第五个就是**存取效率不同。**在栈上面的读取比常数存储区域的读取要快，所以数组定义的字符串读取速度会比指针定义的字符串的读取速度快；



### 堆和栈有什么区别？

1. 第一个是**管理的方式不同**。栈是由编译器自动分配的，用于存储局部变量，而堆是程序员申请分配的。并且，堆和栈属于两块不同的存储区域。
2. 第二个是**增长方向不同**。栈是由高地址往低地址分配的，而堆是由低地址往高地址分配的，栈和堆是相对生长的（可以理解为栈和堆是三文治的两块面包，争夺中间的空间，**目的应该是为了节省内存，相对正常可以充分利用内存空间**）。**同时，栈的大小一般是固定的，大概是1-2Mb；堆的大小一般大很多。**（这个可以用来判断分配在堆还是栈）
3. 第三个是**分配的效率不同**。**栈是一块连续的内存，只要申请的大小小于栈剩余空间**，就分配内存；而堆是**不连续的内存空间，当申请堆的空间的时候，会遍历空闲内存链表**，找到第一块大于等于申请空间的内存块返回给程序，多余的那部分内存将添加回链表，释放的时候再放回链表上；因此，**栈上的分配比堆上的分配高效。**
4. 第四个是**碎片问题**。由于栈的按一定顺序分配和释放的，所以不会存在中间有内部碎片这样的问题，因为某个栈变量释放的时候，其前面的所有变量都会被释放；反观堆，因为是程序员通过new和delete控制的，所以可能会存在大量的碎片，造成分配效率降低。



### C++中有哪些段

1. 一般可以分为TEXT段，DATA段和BSS段；其中TEXT段是只读的，DATA和BSS都是可读写的；
2. TEXT存放程序二进制码，编译时确定；
3. DATA段包括了STACK、HEAP、STATIC段，存放程序运行过程中的局部变量、一些全局变量和静态变量动态分配的变量等；
4. BSS段是一个比较特殊的段，用于存放**未初始化的**全局变量、静态变量，这块区域会**自动置0**，所以未初始化的全局变量静态变量有初值0；



### C++中有哪些存储区域

1. 栈，用于存放局部变量，由编译器自助分配和回收，大小一般为1-2MB；
2. 堆，用于存放动态分配的变量，由程序员控制其分配和回收，大小没有限制，理论上可以达到4GB；如果没有主动回收内存，可能会造成**内存泄漏**，程序结束后会自动收回；
3. 静态存储区与，用于存放全局变量和静态变量；
4. 字符串常量区，用于存放字符串常量，程序结束后自动收回，这块区域是只读的；
5. 程序代码区，存放程序的二进制码，这个区域是只读的；



### C++中static关键字的作用

1. 第一个是**改变变量的生命周期。**一个**局部变量**如果用static修饰，那这个变量的生命周期就变为程序的生命周期，并且存储在全局数据区域，但是其**作用域**不会改变。
2. 第二个是**静态变量只会被初始化一次。**如果再次进行初始化不会产生任何效果，如果没有进行初始化，其值为0；
3. 第三个是**隐藏**。如果存在多个文件同时编译，A文件和B文件中的同名全局变量可能会发生冲突；如果用static修饰一个全局变量，则该变量的作用域变为文件内，在别的文件**即使使用extern也无法获取该变量**；
4. 第四个是**用于修饰类成员变量和类成员函数。**如果修饰了类成员变量或者类成员函数，则其将属于整个类，而不属于任何一个对象；同时，静态成员变量也是之初始化一次，静态成员函数**只能访问静态成员变量**。但是非静态成员可以随意访问静态成员；因为静态成员函数属于整个类，所以没有this指针，所以无法访问具体对象的非静态成员变量。此外，静态类成员变量的初始化必须在类外进行，一般就是在类实现文件中初始化。



### 进程和线程的区别？

1. 进程是操作系统**资源分配**的基本单位，而线程是**处理器调度**和执行的基本单位；

2. 每个进程都有**独立的代码和数据空间（程序上下文）**，一个进程内可以包含多个线程，这些线程共享代码和数据空间，**但是每个线程都有自己独立的运行栈和程序计数器（PC）**；因此，线程之间切换的开销小。程序之间的切换会有较大的开销；

3. 因为线程共享进程的资源，所以某个线程发生错误会导致整个进程终止；而两个进程之间是不会相互影响的；

4. 父和子进程使用进程间通信机制，同一进程的线程通过读取和写入数据到进程变量来通信。

   



### 10亿QQ号，如何找出重复的那一个？

1. 使用**hash+set的方法：**
   1. 首先将所有QQ号对500取模，这样所有QQ号会被分成500组，最重要的是**相同的QQ号肯定在同一组内；**
   2. 然后每一组分别建立一个set，然后遍历自己分组的数据，就能找到那个重复的QQ号；
2. 使用**bitmap位图法：**
   1. 首先我们知道位图可以用一位来表示该数据是否存在，在这里我们用一位来表示QQ号是否存在；因此，假设QQ号都为10位的情况下，QQ号的范围为[10亿，100亿)，也就是说一共90亿个数字，我们用90亿位来表示，90亿位相当于11.25亿字节（**10亿字节=1GB**），也就是总共需要1.125GB内存；
   2. 内存不够的情况下，我们依然选择分组，**这里根据QQ号的首位数字分为1-9共9组；**如果还是太大就根据第二位继续细分；
   3. 从QQ号小的开始用bitmap记录其状态；由于文件间的QQ号是有序的，所以如果1开头的QQ号检查完了，我们可以情况刚才的内存用来记录2开头的QQ号；



### 手写strcpy, strcat, strcmp, memcpy等函数

1. 手写strcpy

   char\* Strcpy(char \*a, const char \*b) {
   	if (a == NULL || b == NULL) {
   		cout << "bad argument." << endl;
   		return NULL;
   	}
   	char \*mark = a;
   	while ((\*a++ = \*b++) != '\0')
   		continue;
   	return mark;
   }

2. 手写strcat

   char\* Strcat(char \*a, const char \*b) {
   	if (a == NULL || b == NULL) {
   		cout << "bad argument." << endl;
   		return NULL;
   	}
   	char \*mark = a;
   	while (\*a != '\0') {
   		a++;
   	}
   	while ((\*a++ = \*b++) != '\0')
   		continue;
   	return mark;
   }

3. 手写strcmp

   int Strcmp(const char \*a, const char \*b) {
   	if (a == NULL || b == NULL) {
   		cout << "bad argument." << endl;
   		return a==NULL;
   	}
   	while (\*a == *b) {
   		if (\*a == '\0')
   			return 0;
   		a++, b++;
   	}
   	return \*a - \*b;
   }

4. 手写memcpy

   void\* Memcpy(void \*a, const void \*b,size_t n) {
   	char \*pa = (char\*)a, \*pb = (char\*)b;
   	if (pa > (pb + n) || pa < pb) {//这里表示a的地址与b的地址没有冲突
   		while (n--)
   			\*pa++ = \*pb++;
   	}
   	else {**//如果b的末尾有部分跟a开头重叠，就从末尾开始复制**
   		pa = (char\*)(pa + n - 1);
   		pb = (char\*)(pb + n - 1);
   		while (n--)
   			\*pa-- = \*pb--;
   	}
   	return a;
   }



### 10机制转16进制

注意10进制转换16进制就是不断除以16，记录余数；然后取商继续除以16，记录余数；直到商为0，这个时候把商逆序就是结果了；

string ten2dex(const string &ori) {
	int temp = stoi(ori),remainder;
	string ans;
	while (temp != 0) {
		remainder = temp % 16;
		temp /= 16;
		if (remainder < 10)
			ans = to_string(remainder) + ans;
		else
			ans = char(55+remainder) + ans;**//A的ASCII码是65，因为remainder要先-10，所以直接+55就ok**
	}
	return ans;
}



### 伙伴算法

由于进程申请内存的大小是任意的，如果操作系统对malloc 函数的实现方法不对，将直接导致一个不可避免的问题，那就是**内存碎片。这些块虽然是空闲的，但是却小到无法使用**。随着申请和释放次数的增加，内存将变得越来越不连续。最后，整个内存将只剩下碎片，即使有足够的空闲页框可以满足请求，但要分配一个大块的连续页框就可能无法满足，所以减少内存浪费的核心就是尽量避免产生内存碎片。针对这样的问题，有很多行之有效的解决方法，其中**伙伴算法被证明是非常行之有效的一套内存管理方法**，因此也被相当多的操作系统所采用。

伙伴算法（Buddy system）**把所有的空闲页框分为11个块链表**，每块链表中分布包含特定的连续页框地址空间，比如第0个块链表包含大小为2^0个连续的页框，第1个块链表中，每个链表元素包含2^1个页框大小的连续地址空间，….，第10个块链表中，每个链表元素包含2^10个页框大小的连续地址空间；**每个链表元素代表4M的连续地址空间**。每个链表中元素的个数在系统初始化时决定，在执行过程中，动态变化。

   伙伴算法每次只能分配2的幂次页的空间，比如一次分配1页，2页，4页，8页，…，1024页(2^10)等等，**每页大小一般为4K，因此，伙伴算法最多一次能够分配4M的内存空间**。

**内存的分配过程：**

1. 如果需要分配4K，即一个页框大小的内存，**首先去链表0查看是否有空闲块**；
2. 如果有空闲块，分配成功；**如果没有链表块，查看下一级，即链表1是否有空闲块**；
3. 如果链表1有空闲块，则**将这块内存分成2块**，一块返回，一块给到链表0；如果没有则以此类推；
4. 如果请求分配的不是2次幂的大小，则会分配比该数要大一点的2次幂的块，**因此会产生内部碎片；**

**回收过程：**

1. 首先定义什么是伙伴，满足三个条件：**①两个块具有相同大小；②物理地址是连续的；③从同一个大块中拆分出来；**
2. 当我们回收到一个大小为b的块的时候，首先检查b的链表里面有没有空闲块，**如果有空闲块并且地址连续，**就将其合并成一个2b的块，然后以此内推，直到不能合或者得到一个2^10的最大块为止；









### linux中SSH是什么？

ssh服务是一个**守护进程，由系统后台监听客户端的连接**，进程名为sshd，端口为22。通过SSH客户端我们可以连接到运行了SSH服务器的远程机器上，也就是说，我们可以**通过ssh来远程控制我们的电脑或者服务器**。那么ssh协议的优点就是**数据传输是加密**的，可以防止信息泄露，而且数据传输是压缩的，可以提高传输速度。

1. 在命令行中输入“**ssh -l root 服务器IP**”可以连接到服务器，也可以使用“**ssh root@服务器IP**”连接到服务器。例如我们使用deepin1：

   ```bush
   ssh -p 22 deepin2@192.168.56.132
   ```

   这里的-p 22 表示22端口，可以忽略；deepin2是我们想连接的那个服务器的用户名，@后面的是deepin2的IP地址；后续还需要输入deepin2的密码；然后就可以直接运行cmd命令行来操作我们的服务器了；

2. **免密登陆：**

   1. 首先，配置公钥。在deepin1终端使用**ssh-keygen**生成公钥；
   2. 然后，上传公钥到服务器。在Deepin1终端中执行ssh-copy-id -p port user@remotr（ssh-copy-id -p 22 deepin2@192.168.56.132）可以让远程服务器记住我们；
   3. 现在连接deepin2不需要密码了；



### accept发生在三次握手哪个阶段？

答案是发生在**三次握手完成之后**。

服务器：申请socket==>setsockopt（可选）==>bind==>listen==>等待连接==>accept==>read==>write==>主动或者被动close；

客户端：申请socket==>setsockopt（可选）==>connect==>write==>read==>主动或者被动close；



### linux基础知识

&  表示任务在后台执行，如要在后台运行redis-server,则有 redis-server &

&& 表示前一条命令执行成功时，才执行后一条命令 ，如 echo '1‘ && echo '2'   

| 表示管道，上一条命令的输出，作为下一条命令参数，如 echo 'yes' | wc -l

|| 表示上一条命令执行失败后，才执行下一条命令，如 cat nofile || echo "fail"



### 如何实现一个单例模式？

单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，**应用该模式的类一个类只有一个实例**。

单例模式分类：

- 饿汉式单例模式：在类加载时就完成了初始化，所以类加载比较慢、获取对象的速度快、以空间换取时间模式、**线程安全**；
- 懒汉式单例模式：在类加载时不初始化、按照需求创建实例、以时间换取空间模式；

具体方法是**将该类的构造函数声明为private**，同时复制构造函数和赋值运算符也声明为private，防止复制和赋值；如果要生成一个类对象必须通过我们的对外接口getinstance，然后声明一个static的类对象，根据需求可以选择饿汉式或者懒汉式的方法；

问题1：内存如何回收？

我们可以在private内声明一个struct，其析构函数判断instance如果不为空则delete，然后将其声明为静态成员变量，**利用程序结束时会自动释放静态变量的特点**实现对单例的析构；

问题2：线程安全吗？

不安全，所以需要用到一个互斥锁，但是简单地使用锁会导致多个线程阻塞在锁的获取，所以可以在加锁前判断instance==NULL，即double check。

代码（懒汉式）：

```cpp
class Singleton
{
  private:
    static Singleton *local_instance;
    static pthread_mutex_t mutex;
    Singleton(){
        cout << "构造" << endl;
    };
    ~Singleton(){
        cout << "析构" << endl;
    }
    class rememberFree{
        public:
        rememberFree(){
            cout << "成员构造" << endl;
        }
        ~rememberFree(){
            if(Singleton::local_instance != nullptr){
                delete Singleton::local_instance;
            }
        }
    };
    static rememberFree remember;

  public:
    static Singleton *getInstance()
    {
        pthread_mutex_lock(&mutex);
        if (local_instance == nullptr)
        {
            local_instance = new Singleton();
        }
        pthread_mutex_unlock(&mutex);
        return local_instance;
    }
};

Singleton * Singleton::local_instance = nullptr;
pthread_mutex_t Singleton::mutex = PTHREAD_MUTEX_INITIALIZER;
Singleton::rememberFree Singleton::remember;
int main()
{
    cout << "单例模式访问第一次前" << endl;
    Singleton * s = Singleton::getInstance();
    cout << "单例模式访问第一次后" << endl;
    cout << "单例模式访问第二次前" << endl;
    Singleton * s2 = Singleton::getInstance();
    cout << "单例模式访问第二次后" << endl;
    return 0;
}
```



### 如何实现一个工厂模式？

工厂模式一般分为三种：**简单工厂模式、工厂方法模式、抽象工厂模式**。

1. 简单工厂模式：

   简单工厂模式，工厂类是创建产品的，它决定创建哪一种产品，就像领导决定采用那种技术方案样。举个例子，现在有宝马车和奔驰车两种车需要生产，但是只有一个工厂，且只能在同一时间生产一种车，这时就有工厂决定生产那种车了。**简单来说，就是根据给定的类型返回对应的类对象就ok了。**但是存在一个问题：每次增加车型的时候都需要修改工厂类，违反了开放封闭原则，即软件实体（类、模块、函数）可以扩展，但是不可修改。

   **优点**：工厂类中包含了必要的逻辑判断，可以根据用户的需求动态实例化相关的类；对客户端来说，去除了与具体产品的依赖。

   **缺点**：违背开放-封闭原则，添加新的产品时需要修改工厂类的内容。

   代码：

   ```bash
   #include <iostream>
   using namespace std;
   
   enum CarType{BENZ, BMW};
   
   class Car//车类
   {
   public:
       virtual void createdCar(void) = 0;
   };
   
   class BenzCar : public Car //奔驰车
   {
   public:
       BenzCar()
       {
           cout<<"Benz::Benz()"<<endl;
       }
       virtual void createdCar(void)
       {
           cout<<"BenzCar::createdCar()"<<endl;
       }
       ~BenzCar()
       {
   
       }
   };
   
   class BmwCar : public Car //宝马车
   {
   public:
       BmwCar()
       {
           cout<<"Bmw::Bmw()"<<endl;
       }
       virtual void createdCar(void)
       {
           cout<<"BmwCar::createdCar()"<<endl;
       }
   };
   
   
   class CarFactory //车厂
   {
   public:
       Car* createSpecificCar(CarType type)
       {
           switch(type)
           {
           case BENZ://生产奔驰车
               return (new BenzCar());
               break;
           case BMW://生辰宝马车
               return (new BmwCar());
               break;
           default:
               return NULL;
               break;
           }
       }
   };
   
   int main(int argc, char** argv)
   {
       CarFactory carfac;
       Car* specificCarA = carfac.createSpecificCar(BENZ);//看到网上众多示例在new后没有delete，感觉不是特别严谨
       Car* specificCarB = carfac.createSpecificCar(BMW);
   
       delete specificCarA; delete specificCarB;
       
       return 0;
   }
   ```

2. 工厂方法模式

   针对简单工厂违反开放封闭原则出现的设计模式。不再只由一个工厂类决定那一个产品类应当被实例化,这个决定权被交给子类去做。当有新的产品（新型汽车）产生时，只要按照抽象产品角色、抽象工厂角色提供的方法来生成即可（新车型可以用一个新类继承创建产品即可），那么就可以被客户使用，而不必去修改任何已有的代码。**简单来说，就是不再依赖于工厂去返回我们需要的对象，而是将工厂作为基类，根据我们的需求去派生出对应的工厂类，利用这个工厂类产生我们需要的对象。**

   **优点**：克服了简单工厂违背开放-封闭原则的缺点。

   **缺点**：每增加一个产品，需要多增加一个对应工厂的类，增加了额外的开发量。

   代码：

   ```bash
   #include <iostream>
   using namespace std;
   
   class Car//车类
   {
   public:
       virtual void createdCar(void) = 0;
   };
   
   class BenzCar : public Car //奔驰车
   {
   public:
       BenzCar()
       {
           cout<<"Benz::Benz()"<<endl;
       }
       virtual void createdCar(void)
       {
           cout<<"BenzCar::createdCar()"<<endl;
       }
       ~BenzCar()
       {
   
       }
   };
   
   class BmwCar : public Car //宝马车
   {
   public:
       BmwCar()
       {
           cout<<"Bmw::Bmw()"<<endl;
       }
       virtual void createdCar(void)
       {
           cout<<"BmwCar::createdCar()"<<endl;
       }
   };
   
   
   class Factory//车厂
   {
   public:
       virtual Car* createSpecificCar(void) = 0;
   };
   
   class BenzFactory : public Factory//奔驰车厂
   {
   public:
       virtual Car* createSpecificCar(void)
       {
           return (new BenzCar());
       }
   };
   
   class BmwFactory : public Factory//宝马车厂
   {
   public:
       virtual Car* createSpecificCar(void)
       {
           return (new BmwCar());
       }
   };
   
   
   int main(int argc, char** argv)
   {
       Factory* factory = new BenzFactory();
       Car* specificCarA = factory->createSpecificCar();
       factory = new BmwFactory();
       Car* specificCarB = factory->createSpecificCar();
       
       delete factory; delete specificCarA; delete specificCarB;
       
       return 0;
   }
   ```

3. 抽象工厂模式

   如果一个工厂需要生产某产品的高端定制版，但是又不想重新定义一个工厂类，就出现了抽象工厂模式。

   **优点**：需求改变时改动最小；具体的创建实例过程与客户端分离，客户端通过抽象接口操作实例，产品的具体类名也被具体工厂的实现分离，不出现在客户端代码中（客户端只知道有一个抽象工厂，一个抽象的Engine和一个抽象的Type）。

   **缺点**；新增功能时，比如火车和飞机都有窗户，那就要增加3个类，还要修改2个具体的工厂类。

   代码：

   ```bash
   #include <iostream>
   using namespace std;
   
   class Car//车类
   {
   public:
       virtual void createdCar(void) = 0;
   };
   
   class BenzCar : public Car //奔驰车
   {
   public:
       BenzCar()
       {
           cout<<"Benz::Benz()"<<endl;
       }
       virtual void createdCar(void)
       {
           cout<<"BenzCar::createdCar()"<<endl;
       }
       ~BenzCar()
       {
   
       }
   };
   
   class BmwCar : public Car //宝马车
   {
   public:
       BmwCar()
       {
           cout<<"Bmw::Bmw()"<<endl;
       }
       virtual void createdCar(void)
       {
           cout<<"BmwCar::createdCar()"<<endl;
       }
   };
   
   class HighCar //高配版车型
   {
   public:
       virtual void createdCar(void) = 0;
   };
   
   class HighBenzCar : public HighCar //高配奔驰车
   {
   public:
       HighBenzCar()
       {
           cout<<"HighBenzCarBenz::Benz()"<<endl;
       }
       virtual void createdCar(void)
       {
           cout<<"HighBenzCar::createdCar()"<<endl;
       }
   };
   
   class HighBmwCar : public HighCar //高配宝马车
   {
   public:
       HighBmwCar()
       {
           cout<<"HighBmwCar::Bmw()"<<endl;
       }
       virtual void createdCar(void)
       {
           cout<<"HighBmwCar::createdCar()"<<endl;
       }
   };
   
   class Factory//车厂
   {
   public:
       virtual Car* createSpecificCar(void) = 0;
       virtual HighCar* createdSpecificHighCar(void) = 0;
   };
   
   class BenzFactory : public Factory//奔驰车厂
   {
   public:
       virtual Car* createSpecificCar(void)
       {
           return (new BenzCar());
       }
   
       virtual HighCar* createdSpecificHighCar(void)
       {
           return (new HighBenzCar());
       }
   };
   
   class BmwFactory : public Factory//宝马车厂
   {
   public:
       virtual Car* createSpecificCar(void)
       {
           return (new BmwCar());
       }
       virtual HighCar* createdSpecificHighCar(void)
       {
           return (new HighBmwCar());
       }
   };
   
   
   int main(int argc, char** argv)
   {
       Factory* factory = new BenzFactory();
       Car* specificCar = factory->createSpecificCar();
       HighCar* spcificHighCar = factory->createdSpecificHighCar();
       
       delete factory; delete specificCar; delete spcificHighCar;
       
       return 0;
   }
   ```







### 为什么有了二叉查找树、二叉平衡树还需要红黑树呢？不同应用场景如何选择红黑树和哈希表？

1. 二叉查找树：

   优点：有序；

   缺点：如果插入顺序不当，会退化成链表；

2. 平衡二叉树：

   优点：有序，且任意左右子树高度差不大于1；

   缺点：插入和删除的后处理太过复杂，在数据量极大的情况下需要花费大量时间重新平衡；

3. 红黑树：

   一种弱化版的平衡二叉树，不要求任意左右子树高度差不大于1，所以插入和删除的后处理相对简单点。

4. 那为什么不用hash要用红黑树呢？

   1. 查找速度：hash的查找速度是O(1),红黑树是O（logn）；
   2. 内存消耗：hash需要一大块内存来映射，所以会有未使用的内存；红黑树取得的内存就是已使用的内存；
   3. 插入和删除：hash是O（1），红黑树是O（logn）；
   4. 数据有序性：hash的数据是无序的，红黑树存储的数据是有序的；



### 什么是跳表？为什么Redis不用红黑树用跳表？

跳表是一种带索引的链表，结合了数组查找的优点和链表插入删除的优点，查询、插入删除复杂度均为O（logn），也因此需要额外的空间存储索引。**还支持范围查找。**

![](img/sl.png)

如上图所示，最下面的才是存储N个数据的链表，第一级索引一般有N/2个节点，第二级一般有N/4个节点，因此第k层索引有N/（2^K）个节点。

1. 查找

   查找从最高级索引开始，当前节点小于查询值，说明在当前节点的后面，此时如果当前节点的next不为空，则继续查询；否则就转移到当前节点的down，即下一级索引继续查找；直到到达最后链表；**加入有h级索引，那么h级索引的节点数为N/（2^h）个，第h级有两个节点，不然没有意义；此时的索引的深度为h=logN-1，因此查找的最多查找logN次就能到达底层，每一层查找次数为常数，所以查找的时间复杂度为O（logn）。**

2. 插入

   首先从最高级节点查询插入的位置，由于插入数据之后也要在索引上添加新的节点，但是如果每次插入都严格按照定义去维护索引复杂度为特别高，所以**采用随机技术决定要在多少层索引添加节点**；例如，通过查询在原始链表找到插入的位置了，然后有0.5的概率插入到一级索引；然后又有0.5的概率插入到二级索引，也就是0.25的概率会插入到二级索引，因为一级没有的节点二级也不会有；因此用概率来保证i级索引只有（0.5）^i个节点。

3. 删除

   删除的同时必须将对应的索引节点也删除了，**从最高级索引开始查找，同时标记命中的节点，**然后开始全部删除；



### 字节跳动面试手撕代码

给定一个多边形各个点的坐标pi，每条边都是垂直或者水平的。给定一个k，将其周长分割成k段，返回每一段的端点坐标。

![](img/zjms.png)

首先使用struct存储坐标（x，y），还有一个哈希表存储对应的变长，**注意这里不要漏了最后一段边长**；我的做法里面对应的lenwh[i]表示rectangle[i]和rectangle[i+1]之间的长度；

1. 首先用totallen统计出周长，然后计算平均每段的长度avglen，这个必须是double，因为不一定能整除；
2. 初始化judge=avglen，用judge判断是否应该到达下一段，如果judge比当前的lenwh[i]长，那就减去lenwh[i]，i++，下一段比较；
3. 如果judge小于lenwh[i]，说明这一段有一个分割点；首先看看这两个点x值或者y值哪个一样就先记录当前的x或者y值，**注意要取（j+1）%n将点循环起来，否则最后一段会越界**；**然后看看这条线是从下到上还是从上到下，**如果是从下到上就加上judge，否则要减去judge；
4. 得到一个分割点之后，先用lenwh[i]减去judge，然后判断avglen是否小于lenwh[i]，如果是，说明还可以分割多一个点，**因此将judge加上avglen**；否则用avglen减去这一段剩余的长度，即lenwh[i]-judge，用于表示下一段的偏移量；
5. 最后输出的时候就输出k个结果就行了，如果不能整除有可能有干扰的结果，我们直接不管；

代码：

```c++
#include <iostream>
#include<bits/stdc++.h>
#include<unordered_map>
using namespace std;
/*
输入：
6 8
0 0
4 0
4 4
3 4
3 1
0 1
输出：
0，0
2，0
4，0
4，2
4，4
3，3
3，1
1，1
*/
struct ord {
	double x;
	double y;
	ord(int x_, int y_) {
		x = x_;
		y = y_;
	}
};
int main() {
	vector<ord> rectangle, ans;//每个点坐标
	unordered_map<int, int> lenwh;//边长
	int n, k, totallen = 0;
	cin >> n >> k;
	for (int i = 0; i < n; ++i) {
		ord temp(0, 0);
		cin >> temp.x >> temp.y;
		rectangle.push_back(temp);
		if (i > 0) {
			lenwh[i - 1] = abs(rectangle[i - 1].x - rectangle[i].x) + abs(rectangle[i - 1].y - rectangle[i].y);
			//lenwh[i-1]表示rectangle[i-1]和rectangle[i]之间的长度
			totallen += lenwh[i - 1];//周长统计
		}
	}
	lenwh[n - 1] = abs(rectangle[n - 1].x - rectangle[0].x) + abs(rectangle[n - 1].y - rectangle[0].y);//最后一段，注意跟第一个点作差
	totallen += lenwh[n - 1];//最后一段
	double avglen = totallen*1.0 / k, judge;//avglen表示平均每段的长度，judge用于判断当前边是否满足分割
	judge = avglen;
	int j = 0;//遍历rectangle
	ans.push_back(ord(rectangle[0].x, rectangle[0].y));//T0就是第一个点
	while (j < n) {
		if (lenwh[j] < judge) {//如果当前的变长不足以分割，就跳到下一个边
			judge -= lenwh[j];
			j++;
		}
		else {//当前边长可以分割
			ord temp(0, 0);
			if (rectangle[j].x == rectangle[(j + 1)%n].x) {//这个分割点的x值已知，取模将所有点组成循环
				temp.x=rectangle[j].x;
				temp.y = rectangle[j].y + ((rectangle[j].y < rectangle[(j + 1)%n].y)?judge:-judge);
				//如果i点在i-1点下方，那么temp.y应该在i点上方，加上judge；否则要减去judge；
			}
			else if (rectangle[j].y == rectangle[(j + 1)%n].y) {//这个分割点的y值已知，取模将所有点组成循环
				temp.y = rectangle[j].y;
				temp.x = rectangle[j].x + ((rectangle[j].x < rectangle[(j + 1)%n].x) ? judge : -judge);
			}
			ans.push_back(temp);
			if (avglen > (lenwh[j] - judge))//如果这一段不能再分割了，更新judge，跳到下一段
				judge = avglen - (lenwh[j++] - judge);
			else
				judge += avglen;//这一段还可以分割，继续分割
		}
	}
	cout << "ordinates are as follow:" << endl;
	for (int p = 0; p < k; ++p)//只输出前k个值，保证不会多，虽然不是整除ans里面会多出来一个值
		cout <<setprecision(2)<< ans[p].x << "," << ans[p].y << endl;
	return 0;
}
```





### 你的WebServer里面主要的CPU占用和内存占用都用到哪里去了？





### 一条SQL执行很慢有什么原因？

1. 如果只是**偶尔查询很慢**

   1. 当我们要往数据库插入一条数据、或者要更新一条数据的时候，我们知道数据库会在**内存**中把对应字段的数据更新了，但是更新之后，这些更新的字段并不会马上同步持久化到**磁盘**中去，而是把这些更新的记录写入到 redo log （innoDB特有，mySQL只有binlog，binlog没有空间的限制）日记中去，等到空闲的时候，在通过 redo log 里的日记把最新的数据同步到**磁盘**中去。不过，**redo log 里的容量是有限的**，如果数据库一直很忙，更新又很频繁，这个时候 redo log 很快就会被写满了，这个时候就没办法等到空闲的时候再把数据同步到磁盘的，只能暂停其他操作，全身心来把数据同步到磁盘中去的，而这个时候，**就会导致我们平时正常的SQL语句突然执行的很慢**，所以说，数据库在在同步数据到磁盘的时候，就有可能导致我们的SQL语句执行的很慢了。
   2. 第二种情况是查询涉及的表或者行被加锁了，所以需要等待锁释放了才可以查询；

2. **查询一直很慢**

   1. **没有用上索引**。例如你的表中有字段a、b、c，但是只有a有索引，这个时候你以b或者c作为约束查询，那只能进行全表过滤，表很大的时候速度就会特别慢；

   2. **还是没有用上索引。**例如你的c字段有索引，但是你查询的约束为c - 1 = 1000，则不会使用索引，只有查询c = 1001才会用上c字段的索引；此外，当左侧使用了函数的时候，也会导致没有用上索引；（存疑，难道不会自动优化？）

   3. **数据库选错索引。主键索引和非主键索引是有区别的**，主键索引存放的值是**整行字段的数据**，而非主键索引上存放的值不是整行字段的数据，而且存放**主键字段的值**。在我们进行查询的时候，**系统会进行判断，是使用全表扫描一次完成；还是使用非主键索引扫描，两次完成；**系统的选择主要是根据**索引的区分度**，当一个索引上面不同的值越多，其区分度就越大；因此，区分度越大的索引，查询的效率就越高；但是每次都检查索引的区分度代价太大，**因此系统会通过采样来判断此索引的区分度**，如果采样预测的区分度很小，就会进行全表扫描，这样就很慢了；

      解决方法：

      ①select \* from T force index（primary） where c<100这一句强制使用a所谓索引来进行查询。

      ②先使用show index from T；查看索引的区分度；如果区分度不准确就使用analyze table T；



### 主键索引和非主键索引的区别？





### 为什么主键索引最好使用自增？

由于对于B+树来说，如果每次插入的加点key都比之前要大，那就可以很方便地直接在最后面插入这个新的节点；如果新插入的节点key处于中间，那就可能需要重新调整B+树的结果，最坏的结果是存储该数据的那个页已经满了，需要进行页分裂才能完成调整。







### 打开一个url全过程？





### mySQL中int（4）和int（8）的区别？char（4）和varchar（4）的区别？

1. int（4）和int（8）：

   正常使用的话，他们并没有什么区别，**int(M)，这个M表示的是显示宽度**，只有在**加上关键字zerofill**的时候，才会有点儿效果比如int(4)，当插入的数据不够4位时，会在数据前面用0补满4位，当超过4位时；

   create table ‘test’（age int（2） **unsigned zerofill** not null default ‘00’）

   当输入的年龄小于2位的时候，前面会补一个0，**当输入的数字超过2位，不会缩小为2位，照常显示；**其实其实际存储都是4字节的一个int整型；

2. char（4）和varchar（4）：

   1. **char的长度是不可变的，而varchar的长度是可变的；**
   2. 定义一个**char[10]如果存进去的是‘abcd’,那么char所占的长度依然为10，除了字符‘abcd’外，后面跟六个空格**；而varchar[10]就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的；
   3. **char的存取速度还是要比varchar要快得多**，因为其长度固定，方便程序的存储与查找；但是char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率，而varchar是以空间效率为首位的。
   4. char的存储方式是，对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节；而varchar的存储方式是，对每个英文字符占用2个字节，汉字也占用2个字节，两者的存储数据都非unicode的字符数据。
   5. 对于varchar，**当数据长度小于255时，数据库采用1个字节记录varchar数据长度**，当数据长度>255时，需要用两个字节存储长度；
   6. char类型字段的最大长度是255，且255个字节可全部用于存储数据；vachar字段的类型最大长度是65535，但实际存储的数据长度要小于该值；



### mySQL中空值和NULL值有什么区别？

1. 空值不占空间，NULL值占空间；
2. 定义为NOT NULL的字段只能插入空值，不能插入null值；而NULL字段可以插入空值，也可以插入null值。
3. 可以发现 is not null 只会过滤为null值的列，而=会同时过滤空值和null值，所以要根据实际情况选择过滤方式。因此，**判断null值只能用 is null 或 is not null ，不能用 = 或 <>。**
4. 在进行count()统计某列的记录数的时候，如果采用的NULL值，会别系统自动忽略掉，但是**空值是会进行统计到其中的。 **
5. 当使用ORDER BY时，首先呈现NULL值。如果你用DESC以降序排序，NULL值最后显示。即**排序时默认NULL值比空值小**；
6. 当使用GROUP BY时，所有的NULL值被认为是相等的，故只显示一行。



### 进程、线程、协程、管程？





### HTTP状态码解析





### http和https的区别？

