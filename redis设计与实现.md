## 一、数据结构与对象

### 简单动态字符串

1. simple dynamic string，简称SDS，是一个C语言实现的智能扩增的字符串类；

2. struct sdshdr{

   int len；//保存字符串的长度

   int free；//记录buf未使用的字节

   char buf[]；//用于保存字符串

   }

3. 空间预分配：

   ①如果长度小于1MB，就会分配两倍的空间；

   ②如果长度大于1MB，就会分配请求的空间+1MB的空间；

4. 惰性空间释放：

   SDS在字符串缩短之后，不会立刻将空间重新resize，而是存储在free里面，后续可能还会用到，所以先保存着；如果有需要，可以强行收回空间；

5. **二进制安全**

   由于SDS是根据len属性来判断字符串是否为空，所以及时是二进制数据，比如‘\0’都可以保存，还可以正常读出。

6. 总结：

   ![](img/redis1.png)

7. API

   ![](img/redis2.png)





### 链表

1. struct listNode{

   void \*value;//值

   struct listNode \*prev;//前置节点

   struct listNode \*next;//后置节点

   }

2. 上面的是listNode，这个是list的结构

   struct list{

   listNode \*head;//头结点

   listNode \*tail;//尾节点

   unsigned long len;//链表长

   void\* (\*dup)(void \*ptr);//阶段复制函数

   int (\*match)(void \*ptr,void \*key);//节点值对比函数指针

   void (\*free)(void \*ptr);//节点释放函数指针

   }

3. API

   <img src="img/redis3-1.png" style="zoom:75%;" />

   <img src="img/redis3-2.png" style="zoom:75%;" />





### 字典

是一种保存key-value的抽象数据结构

1. ![](img/redis4.png)

   这个table连接着一个**哈希表**，这个哈希表的长度为size，可以理解为hashtable[size]；

2. 哈希表的节点：

   ![](img/redis5.png)

   可以看到，这里的next**指向下一个哈希表**，其数据类型为dictEntry；

3. **字典的两个结构体：**

   ![](img/redis6.png)

   ![](img/redis7.png)

   type和privdata是为了创建多态字典而设置的，privdata的结构体如上所示；

4. ht里面包含了两个哈希表，正常情况下只会使用0号哈希表，**进行rehash的时候才会使用1号哈希表**，平时1号哈希表就是空的；

5. redis使用**链地址法解决冲突**。每一个key-value都会用一个节点保存起来，如果发生冲突，使用next指针拉起一个链表。

6. **rehash操作**

   为了将负载因子保持在合理范围，在数据太多或者太少的时候需要进行rehash

   负载因子的计算方法：loda_factor=ht[0].used/ht[0].size；

   负载因子大于等于1的时候扩展，小于等于0.1的时候收缩；

   **万一在rehash的时候进行查询怎么办？**

   为了防止这种情况，rehash是渐进式的，不是阻塞执行的，其步骤为：

   ①首先根据ht[0].used获取键值对的数量；如果是扩展，ht[1]的大小为2^n，其大小刚好大于ht[0].used\*2；如果是收缩，ht[1]的大小为2^n，其大小大于等于ht[0].used；

   ②在字典中维持一个rehashidx=0，表示rehash正式开始；这个值表示已经rehash成功的元素的个数，当全部完成，rehashidx=-1，表示rehash结束；

   ③将ht[0]上的键值对重新计算哈希值和索引值，rehash到ht[1]里面；

   ④rehash完毕之后，释放ht[0]，将ht[1]转移到ht[0]；ht[1]创建一个空表，为下次rehash做好准备；

   ⑤在rehash过程中，**查询**先在ht[0]进行，失败再到ht[1]；**新增**只会在ht[1]中执行；**删除和更新**会两个表同时进行；

7. API

   ![](img/redis8.png)



### 跳跃表

是一种数据结构，支持平均查找时间O（logN），最坏O（N）的查找。

1. 其实现：

   ![](img/redis9.png)

   **跨度**表示前进指针到达的两个节点之间的距离，用以计算目前到达的节点的下标；

   **后退指针**可以理解为双向链表的prev，不能跨越多个节点，只能逐个回退，**只有最底层有**；

   **分值**是一个double类型的浮点数，跳表中的所有节点都按照分值升序排列，**多个节点分值可以相等**；

   **成员对象**一般就是一个SDS，**多个节点的成员对象必须唯一**；

2. 上面是跳跃表的节点，下面是跳跃表：

   ![](img/redis10.png)

3. 一个跳表的示意图

   ![](img/redis11.png)

4. API

   ![](img/redis12.png)





### 整数集合

如果一个集合只包含整数，且元素不多，redis就会选择整数集合来保存

1. 整数集合intset的结构体：

   ![](img/redis13.png)

   整数集合里面不会存在重复的元素。length就是contents的长度，contents用来存储整数；

   encoding表示存储的数据的类型，如果是INTSET_ENC_INT16那就是16位整数，还有很多，下面是一个示意图：

   ![](img/redis14.png)

   由于**每个元素的大小为64位，所以总的长度为64\*4=256位。**

   即使只有一个元素需要64位存储，其他的元素类型必须统一，所以这里肯定是取最大的一个类型；

2. **升级**

   当新添加的一个元素的长度超过了encoding，那就要升级了，步骤为：

   ①根据新的类型分配足够的新空间；

   ②所有元素的类型都要转换为统一类型，然后放置在应该在的位置（根据它当前的下标乘以升级后的长度），有序性不变；

   ③将新的元素插入这个整数集合；

3. **降级**

   目前不支持降级，升级之后，这个整数集合的encoding不会下降；

4. API

   ![](img/redis15.png)





### 压缩列表

压缩列表是列表建和哈希键的底层实现之一。

1. 具体结构

   ![](img/redis16.png)

   这里的zlbytes表示整个列表的长度，zltail指向最后一个节点；

2. 压缩列表里面entryN，也就是节点的构成：

   1. previous_entry_length：前一个节点的长度，**用来访问前一个节点**；
   2. encoding：表示这个节点保存的数据类型；
   3. content：实质的内容是什么，就看这个content了；

3. API

   ![](img/redis17.png)







### 对象

这个很熟悉了，就是面向对象里面的对象，很重要

1. 对象的结构：

![](img/redis18.png)

2. 类型：

   ![](img/redis19.png)

   **对象的键总是字符串**，其值为上述的类型之一，我们所说的“字符串键”是指存储的值类型为字符串；

3. 编码和底层实现：

   底层实现指向数据结构，编码表征这个底层实现的具体实现。

   **type msg是查看msg的类型；object encoding msg是查看msg的编码；**

   例如：

   set msg “hello world”

   type msg 返回string

   object encoding msg 返回embstr；

4. 字符串对象：

   一般分为int、raw、smbstr；

   ①如果值为整型，那就是int；

   ②如果是很长的字符串，那就是raw；

   ③如果是短字符串或者浮点数，那就是smbstr；

5. 字符串的一些操作：

   ![](img/redis20.png)

6. 列表的一些操作：

   ![](img/redis21.png)

7. 哈希表的一些操作:**哈希表的底层实现为ziplist或者hashtable**

   ![](img/redis22.png)

8. 整数集合对象的操作：**整数集合的底层实现为intset或者hashtable**

   ![](img/redis23.png)

9. 有序列表：**有序列表的底层实现为ziplist或者skiplist**

   ![](img/redis24.png)

   跳表的底层实现包含**一个跳表和一个字典**。

   使用跳表的好处是**元素存储是有序的，可以以O（1）实现范围性的操作**；但是按照键随机访问就需要O（N）；

   使用字典可以按照键达到O（1）的访问，但是由于数据是无序存储的，所以基于范围性的操作要先排序然后再做；

10. **Redis中的命令多态**

    1. del、expire、rename、type、object这些命令**可以对任意键执行**，这是一种**基于类型的多态**；
    2. sadd、spop等只能对集合键执行，但是其底层实现有两种，这也是一种**基于编码的多态**；



### 一些比较重要的概念

1. **内存回收！**

   通过对对象**构建一个引用计数**，在适当的时候自动释放对象；这不就是C++里面的智能指针shared_ptr要做的事情吗？

2. **对象共享！**

   如果A集合已经存在一个对象为整数100，然后B集合也需要一个整数100，那么**A和B会共享这个对象，这个对象的引用计数+1**；

   服务器启动的时候，会自动创建0~9999的字符串对象；然后需要的时候直接共享这些对象就行；

   如果你set A 100，然后object refcount A会返回2，说明这个A只是引用了服务器启动创建的那些对象而已；

3. **对象的空转时长！**

   对象里面还有一个属性：lru，就是最近最长时间没访问的意思？该属性**记录了对象最后一次被访问的时间；**

   可以使用object idletime X来访问对象X的空转时长；





## 二、单机数据库的实现

### 数据库

1. 在redis.h/redisServer里面保存着一个redisDb的数组，这个数组里面是很多的数据库；还有一个属性dbnum表示redisDb里面数据库的数量，dbnum的值由服务器配置的database选项决定，默认值为16；

2. **默认使用的是0号数据库**，也就是平时我们随便set A 100就是在0号数据库；可以使用select n来切换到n号数据库，当时get A 就是一个（nil）了；redis服务器和客户端对数据库的使用可以由下图所示:

   ![](img/redis25.png)

   其实我们使用select就是改变指向客户端的db而已，server的db是没有变的；

3. **数据库键空间**

   **redis是一个键值对数据库服务器**。使用了一个dict来保存所有的键值对，这个dict就是键空间；

   下面是一个形象的例子：

   ![](img/redis26.png)

   ![](img/redis27.png)

   可以看到，**dict里面保存了很多的对象**，对象的键是字符串，例如message、alphabet；这个对象的值就看具体的实现了，可以是字符串、列表、哈希表、集合、有序集合五种其中之一；

4. 一些基本操作：

   1. 新增键值对：

      set msg “hello”或者rpush number 1 2 3 6等都是可以的；

   2. 删除键值对：

      del msg或者del number；

   3. 更新键值对：

      就是再次使用新增键值对的命令，会直接覆盖掉；如果对应的键**类型不同**，例如将哈希表更新为字符串会报错，这个时候先del删除掉，再重新操作；

   4. 对键取值：

      各有不同，例如字符串就是get；列表就是lrange等等；

5. **进行查询时的一些维护操作**

   1. 服务器维护了查询是否命中的计数，分别是keyspace_hits（命中次数）和keyspace_misses（未命中次数），可以使用info stats查看；
   2. 使用flushdb可以情况整个数据库；当数据库不为空，可以使用randomkey返回随机一个键；
   3. 对于查询过的键，更新其lru属性，可以使用object idletime X来查看X的上次访问距离当前的时间；
   4. **如果读取一个键已经过期了，就先删除这个键，然后执行剩余的操作；**
   5. 如果使用watch监视某个键，修改这个键之后就标记为dirty，用于事务程序中；
   6. 服务器每次修改一个键，就会对dirty键+1，会**触发服务器的持久化和复制操作；**
   7. 如果开启了数据库通知，对键的修改会发出通知；

6. **设置键的过期时间**

   使用expire和pexpire来控制某个键的过期时间，过期之后这个键就会被删除；

   例如：

   ![](img/redis28.png)

   这里的expire表示秒，pexpire表示毫秒；

   可以使用time获取当前的UNIX时间戳，用以设置具体的过期时间戳；

   如说使用**ttl X**可以获取X距离过期剩余的时间，pttl返回的是毫秒精度的时间；

   ![](img/redis29.png)

   这里的expireat表示过期时间设置为timestamp时间戳格式，要配合time命令使用；

   一共有四种设置过期时间的命令：

   1. expire：精度为秒；
   2. pexpire：精度为毫秒；
   3. expireat：时间戳模式，精度为秒；
   4. pexpireat：时间戳模式，精度为毫秒

   其实只有4.pexpireat是设置过期命令的，其他三种都是进行转换然后调用它；

   具体关系为：

   ![](img/redis30.png)

7. 保存过期时间

   redisDb结构的expires字典保存了所有键的过期时间；expires字典里面的键指向对应的键值对的地址，值表示这个键值对的过期时间戳；

8. 删除过期时间

   persist命令是expire的反命令，其实现就是在expires字典里面删除对应键的过期时间戳；

   例如：

   persist X就会将X的过期时间删除，这样X就会永久存在了；

9. 返回过期时间：

   通过ttl X返回X距离过期还有多少秒；pttl返回毫秒；

   返回值为-1表示该键没有设置过期时间；

   返回值为-2表示该键不存在于数据库；

10. **过期键的删除策略**

    一般来说，一共有三种策略（**并不是说redis就是这样的策略**）：

    1. 定时删除：主动删除策略，**创建一个定时器，当到达指定时间的时候，删除对应的键；**好处是删除速度最快，对内存很友好；缺点是对CPU时间不友好，Redis服务器中的时间事件是一个无序链表，查找复杂度为O（N），如果有大量的时间事件，会创建大量定时器，消耗CPU资源；
    2. 惰性删除：被动删除策略，只有我们访问对应键的时候才检查是否过期，如果过期了就删除，否则就返回结果。好处是对CPU友好，如无必要，绝对不占用CPU资源；缺点是对内存不友好，如果长时间没有访问，内存中充斥着大量的过期键值对，可以理解为内存泄漏。
    3. 定期删除：主动删除策略，定期检查一遍键值对，删除过期的键值对。是定时删除和惰性删除的折中方案，但是删除时间间隔太长就变成了惰性删除，间隔太短就变成了定时删除，这个间隔比较难把握；

    Redis的删除策略：

    **使用惰性删除+定期删除两种策略。**

    1. 惰性删除的时间点就是在我们访问数据库对应键值对的时候，调用expireIfNeeded判断是否过期，过期则删除，未过期则继续执行；
    2. 定期删除的时间点在服务器周期性执行serverCron的时候调用函数activeExpireCycle，从一定数量的数据库中**随机**取一定数量的键检查是否过期，如果检查的途中中断了，会根据全局变量current_db继续刚才检查的数据库；

11. **AOF、RDB的复制功能与过期键**

    1. 调用save或者bgsave的时候会生成rdb文件，保存的时候会检查整个数据库里面所有的键，如果这个键已经过期了，那就不会加入到rdb文件；
    2. 从rdb载入的时候，同样会检查里面的键，过期的键不会被载入；**仅针对主服务器模式，如果是从服务器模式不管过不过期会全部载入；**
    3. 服务器以AOF持久化模式运行时，某键还没有删除的时候，不会有影响；当该键过期被删除的时候，**会在AOF文件中追加一个del命令显示说明删除该键**；对AOF重写的时候就不会写入过期数据了；

    ### 复制

    1. 当服务器运行在复制模式时，主服务器删除某键，**会群发一个del命令让从服务器删除该键；**从服务器只受主服务器控制，如果客户端访问从服务器，即使那个键过期了，一样可以返回，并且不会删除；

12. **数据库通知**

    客户端通过订阅给定的频道或者模式，来获取数据库中的变化，以及数据库中命令的执行情况；

    有两种模式：

    1. **订阅一个键，返回在该键执行的操作**，关键字为keyspace：

       ![](img/redis31.png)

    2. **订阅一个操作，返回该操作执行的键**，关键字为keyevent：

       ![](img/redis32.png)

    3. 通知功能的实现原理：

       服务器设置notify-keyspace-events选项表示了发送哪一类通知：

       1. AKE：所有的通知；
       2. AK：所有的keyspace通知；
       3. AE：所有的keyevent通知；
       4. K$：只发送关于字符串键的keyspace通知；
       5. EL：只发送关于列表的keyevent通知；

       在服务器执行某个操作成功之后，会调用notifyKeyspaceEvent，传入操作的类型（分为keyspace和keyevnet）、命令名称、对应的对象等信息；

       ①首先检查服务器是否允许发送该通知；

       ②然后检查是否允许发送对应事件的类型以及键，如果允许就发送，否则直接return；





### RDB持久化

RDB持久化的方式是生成一个经过压缩的RDB文件，**包含了当前数据库的所有键值对**，可以通过RDB文件恢复数据库的状态。

1. 有两个命令可以实现RDB持久化：save和bgsave
   1. save

      save命令会**阻塞执行**RDB持久化，此时服务器不能处理任何请求；

      save命令由于是阻塞执行，此时如果再次执行save、bgsave、bgrewirteaof都会被拒绝；

   2. bgsave

      bgsave会生成一个子进程，**由子进程完成save操作**，完成后给服务器发送一个signal；

      bgsave执行时，save和bgsave都会被拒绝；

      同时，bgsave和bgrewriteaof是互斥的，其中一个在执行，另一个就会被拒绝；**虽然两个命令都是子进程去完成的，但是由于都是对硬盘执行写入操作，所以不允许同时运行；**

2. 间隔保存的实现：

   1. 在redisServer内有一个结构体数组：

      ![](img/redis33.png)

   2. 通过命令save seconds changes，如果**在seconds内进行了changes次修改，数据库就会自动执行bgsave；**

   3. seconds主要通过lastsave（记录上一次save或者bgsave的时间戳）；changes主要通过dirty（上一次save或者bgsave之后数据库修改了多少次）；这两个参数实现自动保存；

3. RDB文件的结构：

   ![](img/redis34.png)

   1. REDIS：一个常量，长度5字节，内容为“REDIS”，标志这是redis的文件；
   2. db_version：数据库版本，一般就是0006，；
   3. databases：数据库的数据；
   4. EOF：长度1字节，标志着数据库文件已经全部载入完毕；
   5. check_sum：检验和，检查前面的部分是否有损坏；

4. 分析RDB文件

   命令行中使用od -c dump.rdb可以打印RDB的具体信息；



### AOF持久化

AOF是append only file的缩写，**通过保存所有对数据库造成实际影响的命令**来进行数据库持久化。

例如：

执行set msg “hello”

就会在AOF文件中加入一句set msg "hello“

1. AOF持久化的实现原理

   分为命令追加、文件写入、文件同步三部分。

   1. 命令追加：

      在redisServer结构体内，有一个aof_bud，aof缓冲区，当我们执行一个指令的时候，这个指令会被复制到该缓冲区；

   2. 文件写入：

      每100ms会执行一个redisCron循环，会执行flushAppendOnlyFile函数，该函数根据所选策略对aof缓冲区中的指令写入文件；

   3. 文件同步：

      为了减少硬盘IO，提高效率；**系统调用write会把数据暂时写入内存缓冲区，**当内存缓冲被填满或者超过一定时间，才会将其真正写入硬盘；系统调用fsync和fdatasync可以强制进行文件同步，执行写入硬盘；

2. AOF文件载入与数据还原

   **首先，创建一个不带网络连接的伪客户端；**然后不断执行AOF中的命令，最终就会还原数据库了；

3. **AOF重写**

   当执行了很多的命令之后，AOF文件会特别大，此时会执行AOF重写；其具体实现过程为：

   例如，我们执行了：

   ![](img/redis35.png)

   AOF中应该有4条命令，其实这是一种冗余；所以重写之后，AOF只有一行命令：

   SADD animals “Dog” “Panda” “Tiger” “Lion” “Cat”

   这样就不会有任何的冗余了，**注意，过期的键值对会被自动过滤，重写之后不会包含；**

   当然了，如果一个命令超出了我们的限制，例如一次性添加64个以上的sds到set中，那么此时会自动将命令划分为多个，保证每次执行命令都不会超出限制；

   **那么如何实现后台AOF重写（BGREWRITEAOF）呢？**

   1. 首先，创建一个子进程执行AOF重写；**为了避免竞态条件，子进程拥有一个数据库的副本；**
   2. 在AOF重写过程中，服务器中的**AOF重写缓存将会起作用**，所有的命令都会复制到这个缓存当中，也就是说，此时客户端的命令会被复制到AOF缓存和AOF重写缓存中；
   3. 当重写完毕，子进程会被撤销；父进程收到signal之后将AOF重写缓存中的命令写入AOF文件；
   4. 将新的AOF覆盖旧的AOF，完毕；





### 事件

Redis中有两种事件：①文件事件，就是客户端的命令那种；②事件事件，分为周期事件和定时事件；

1. 文件事件

   1. **Redis服务器就是一个事件驱动程序，其基本架构为Reactor反应堆；**

   2. 也就是大家最熟悉的，使用IO多路复用evport、epoll、kqueue、select（**效率从高到低排列**），同时监听多个套接字（客户端），当收到连接请求、可写、可读信息时，调用文件事件分发器执行相应的程序；

   3. **redis是单线程的**，所以如果有很多socket同时由响应，会有一个队列负责排列所有事件，按序执行；

      单线程好处：①线程安全，操作的时候不用加锁；②没有线程切换的开销，效率极高；

   4. 具体的过程可以概括为：客户端请求连接->服务器执行连接应答处理器->客户端发送命令->服务器执行命令请求处理器->服务器生成命令的回复->服务端执行命令回复处理器；

   5. 当然，对于不活跃的客户端是会被关闭的；

   6. 如果同时收到可写和可读，**会优先执行可读，然后执行可写**；

2. 时间事件

   一个时间事件包括id、when、timeProc，分别表示**全局唯一的事件id号，从小到大递增**、毫秒级别计时器、一个函数；**timeProc的返回值如果是AE_NOMORE，那就是定时事件；如果是别的，都是周期性事件；**

   可以分为：**定时事件**：让一段程序在指定时间之后执行一次；**周期性事件**：每隔指定时间让一段程序执行一次；

   1. 实现：

      所有的时间事件组成一个无序链表，按照id从大到小排列，也就是新事件是头插法插入的；**无序是指：时间不会按照when来排列，哪个事件先发生不会知道；**因此，在实际使用中，每一次都是遍历整个链表的；

   2. **同时存在定时和周期的时候，如何调度？**

      文件事件是随机出现的，时间事件是已知的，为了不让任何一方出现饥饿，调度策略如下：

      1. 首先获取最快到达的时间事件距离现在还有多久；
      2. 如果这个时间已经到达了，那就执行；
      3. 如果还没到达，在这段时间内服务器进入等待并执行文件事件的状态；
      4. 当时间事件到达，从3状态返回，开始执行时间事件；
      5. **所有的事件都是不可抢占的、原子的，所以时间事件并不定会准时，有可能稍微晚点；**

   

   

   ### 客户端

   redis是典型的一对多服务器，redis使用redisClient来记录客户端的状态：

   ![](img/redis36.png)

   1. 套接字属性：就是客户端的socket啦；正常的客户端socket都是大于1的，只有一个**指定Lua脚本的伪客户端socket为-1；**

   2. 名字：一般为空，可以设置；

   3. 标志：表示客户端当前的状态；例如当主从复制的时候，主服务器会成为从服务器的客户端，从服务器也会成为主服务器的客户端；标志为REDIS_MASTER的就是主服务器了，而REDIS_SLAVE就是从服务器；

   4. 输入缓冲：暂时存放客户端的命令，是一个sds，超过1G就会自动释放并断开连接；

   5. 命令和命令参数：服务器会解析客户端输入缓冲里面的命令，将其整理成一个数组：

      ![](img/redis37.png)

   6. 命令的实现函数：是一个指针，在redis里面有很多的命令执行函数，根据argv[0]里面的命令，指向对应的命令执行函数；

   7. 输出缓冲：每个客户端有两个输出缓冲，一个固定大小16KB，一个大小可变；固定的用于回复那些很短很常见的回复，例如OK，错误回复等；返回整个集合、列表这些就要用可变缓冲；

   8. 身份验证：按需使用，可以鉴别该客户端是否已经验证；

   9. 时间：包含三个时间ctime（已经连接了多久）、lastinteraction（最后一次互动到现在过了多久）、obuf_soft_limit_reached_time（软性约束时间，当输出缓冲超过某个阈值会开始计时，到达这个时间就直接断开连接）

      例如，硬性约束为1G，输出缓冲超过1G立刻断开；软性约束为600M，超过600M开始计时，期间输出缓冲一直超过600M，时间到了就断开；

   10. 伪客户端包括：Lua脚本客户端，**服务器存在它就会存在；**载入AOF时生成的伪客户端，**载入完毕就关闭**；

   

   

   

   ### 服务器

   我们直到，服务器会解析客户端的命令然后保存到一个argv数组，解析的过程如下：

   1. 查找命令实现：

      根据argv[0]的命令，在command table命令表字典中找到该命令对于的函数，将客户端的cmd指针指向该函数；每个函数有参数个数要求arity，如果参数个数为-n，表示接受>=n个参数；如果参数个数为n，表示接受n个参数；

   2. 准备执行命令：

      检查cmd如果为NULL，返回错误；检查artiy，看看参数个数对不对；检查身份验证（可选）；检查maxmemory（可选），如果内存不足则进行回收，回收失败返回错误；

   3. 调用命令执行函数：

      直接client[i]->cmd->proc(client[i])；

   4. 后续工作：

      ①如果打开了慢查询日志，根据刚才命令的执行时间决定是否添加；

      ②更新redisCommand结构的一些参数；

      ③将命令写入AOF缓存；

      ④如果这是个主服务器，将其同步到从服务器；

   5. 向客户端回复结果

   后续要更新一些事件参数，一些指标例如每秒执行任务数、内存峰值记录等；

   然后还有一些redisCron内要做的，清除不活跃客户端、过期数据、检查是否关机、持久化、主从同步、等等；





## 三、多机数据库的实现

### 复制

在多服务器情境下，可以使用**SLAVEOF**将数据库变成从服务器：

127.0.0.1：6379> SLAVEOF 127.0.0.1：12345，**表示6379变成了从服务器，12345变成主服务器**

![](img/redis38.png)

**旧版复制功能分为：同步、命令传播**

1. 同步

   执行slaveof之前，从服务器会向主服务器发送sync进行同步操作：具体如下：

   1. 主服务器执行BGSAVE，同时用一个写入缓存记录这段时间的写入命令；
   2. 将这个**rdb文件**发给从服务器，从服务器使用这个rdb文件还原自己的数据库；
   3. 主服务器将**缓存里的命令发给从服务器**，保证数据库一致；

2. 命令传播

   发送在同步完毕之后，所有对数据库进行修改的命令，主服务器都会拷贝一份发给从服务器，以保证数据库的一致性；

旧版复制存在的问题：

如果从服务器掉线了，会自动重连，但是重连成功之后要再次进行同步；**断线的期间数据量改动可能不是太大，同步操作太废资源了，不可取**；

**新版复制：**

新版本复制使用PSYNC进行同步，有完整同步和部分同步两种，

1. 完整同步：与旧版SYNC基本一致；

2. 部分同步：同于重连之后。如果条件允许，从服务器会从主服务器接收掉线期间的命令，然后执行这些命令就可以恢复一致；

   部分同步的实现包括：**主服务器的复制偏移量、从服务器的复制偏移量；主服务器的复制积压缓存；服务器的运行ID**

   1. 复制偏移量

      主服务器和从服务器都有一个复制偏移量，表示向从服务器发送的字节数或者从主服务器接收的字节数，优点像TCP连接里面的序号；**只要复制偏移量相等，那就是一致的**；

   2. 主服务器的复制积压缓存（默认1MB）

      我们发现复制偏移量不一致，那怎么办恢复一致呢？答案就是利用复制积压缓存；这个缓存是**一个固定长度的FIFO的队列**，当满了的时候，会弹出队首的数据，以接收新的数据；在主服务向所有从服务器进行命令传播的时候，这个命令也会发送到复制积压缓存；示意图：

      ![](img/redis39.png)

      **PSYNC的执行情况**

      1. 如果重连之后，从服务器的偏移量offset+1还存在于积压缓存，那就直接开始复制；
      2. 如果offset+1已经不存在了，只能进行完整复制；

   3. 服务器的运行ID

      每个服务器都有自己的ID，是一个40个随机十六进制字符组成；**用于鉴别重连之后，该主服务器是不是断线之前的那个主服务器；**进行初次复制的时候，从服务器会保持主服务器的ID；重连之后比较自己保存的这个主服务器ID与当前的主服务器ID是否一致就知道主服务器是否进行过更换；

   **PSYNC命令的实现**

   当我们执行PSYNC的时候，从服务器会发送**PSYNC ? -1（之前没有复制过主服务器）**或者**PSYNC \<id\> \<offset\>（之前复制过主服务器）**；

   主服务器会回复**FULLRESYNC \<id\> \<offset\>（表示进行全复制，id和offset是主服务器的参数，作为从服务器的初始值）**或者**CONTINUE（表示部分同步）**或者**ERR（主服务器版本太低，无法石碑PSYNC命令）**

   **复制的全过程：**

   1. 设置从服务器中的一些参数：

      ![](img/redis40.png)

   2. **建立TCP连接**；

   3. 发送PING命令：**连接完成后发送的第一个命令。**作用：

      ①检查读写是否正常；

      ②检查命令解析是否正常；

      ③检查网络状况是否良好；

      ④如果收到PONG，表示一切正常；

   4. 身份验证（可选）：

      如果从服务器设置吗masterauth，则进行身份验证；

      从服务器会发送AUTH \<masterauth\>给主服务器，跟主服务器额requirepass作对比，正确则通过；

   5. 发送端口信息：从服务器向主服务器发送自己的监听端口，主服务器保存起来；

   6. 同步：就是上述的PSYNC命令了；**注意，在同步之前，只有从服务器是主服务器的客户端；同步之后，主服务器也会成为从服务器的客户端；**

   7. 命令传播

3. **心跳检测**

   发生在**命令传播阶段，**从服务器以每秒一次的频率，向主服务器发送：

   REPLCONF ACK \<replication_offset\>

   其中replication_offset就是从服务器的offset，有三个作用：

   **检查网络连接；辅助实现min-slaves；检查命令丢失；**

   1. 检查网络连接

      正常情况下1s内必须会响应，否则就是出问题了；

   2. 辅助实现min-slaves

      ![](img/redis41.png)

   3. 检查命令丢失

      如果主服务器发现从服务器的offset小于自己，那就是主服务器发送的命令丢失了；此时就会发送从服务器缺失的数据，一般就在复制积压缓存里面；与PSYNC的区别在于**PSYNC是从服务器重连之后发送的命令，这个是主服务器主动执行的，过程倒是很类似；**



### Sentinel

sentinel（哨兵）是redis**高可用**的解决方案：由一个或多个sentinel实例组成sentinel系统可以监视任意多个主服务器，并在主服务器下线时，**自动从主服务器所属的其中一个从服务器升级为主服务器；**然后其他的服务器都会成为新服务器的从服务器，**并开始复制主服务器的数据进行同步；**当之前下线的服务器上线了，也会变成其中一个从服务器；

![](img/redis42.png)

1. sentinel的初始化

   sentinel其实就是一个特殊的redis服务器，但是有专用的sentinel代码，不加载rdb或者aof文件；

   下面是一个sentinel实例的结构图：

   ![](img/redis43.png)

   **主服务器可以用户自主设定**，设定之后会在结构体上显示：

   ![](img/redis44.png)

   初始化的最后，**sentinel会创建两个与redis主服务器的连接**：

   ①命令连接，用于发送和接收信息；②订阅连接，订阅主服务器的hello频道；

   **为什么有两个连接？**由于在目前的redis发布与订阅功能中，被发送的信息**不会存储在redis当中**，如果客户端掉线，则无法接收到这条信息；为了不丢失这条信息，所以要**增加一个hello频道的订阅连接**；但是sentinel需要向redis服务器发送信息，因此就需要用于收发命令的连接。

2. sentinel监视

   **对于每一个从服务器，都会有两个sentinel连接；**sentinel和sentinel之间只有命令连接；

   每隔10s，sentinel会**主从服务器发送INFO信息**，返回的信息包括主服务器run_id等信息以及从服务器的ip：port信息；**当主服务器重启，run_id会改变**；然后将新的信息添加到sentinel的结构体中；

   每隔2s，sentinel会向所有的主从服务器发送一个命令；用以获取服务器实时的运行情况；

   **每隔1s，sentinel会向所有的主从服务器发送PING命令，通过PING命令来检测该服务器是否下线；**服务器会返回PONG、LOADING、MASTERDOWN三种命令的其中一种，如果超过用于预设时间没有返回有效的应答，则**主观认为其已下线；**

   **如何客观判断redis服务器下线？**

   当一个sentinel判断一台服务器主观下线，会向监视同一个服务器的其他sentinel询问是否该服务器已下线；如果获得足够多的主观下线信息，则**改为客观下线**；

3. **故障转移**

   如果主服务器已下线，则需要进行故障转移；

   ①从主服务器的从服务器中选择一个作为新的主服务器；

   ②所有的其他从服务器开始复制新的主服务器的数据；

   ③如果旧的主服务器上线，则成为其中一个从服务器；











### 集群

1. 节点

   **一个redis集群由多个节点组成**；一个节点就是一个redis服务器，节点间可以通过cluster meet命令进行握手，握手成功则会成为一个集群；
   
   每个节点都有一个clusterNode结构体来记录节点的状态，包括ip、port、**纪元（用于故障转移）**、创建时间，结构体如下：
   
   ![](img/redis45.png)
   
   由于节点不是孤立的，所以**每一个节点都会为与他处于同一集群的其他节点创建一个clusterNode**；
   
   **CLUSTER MEET的实现**
   
   如果A想B发送一个cluster meet <ip> <port>，那么A、B就会处于同一个集群了；
   
   ①首先A为B创建一个clusterNode；
   
   ②**A向B发送MEET命令；**
   
   ③B收到命令，为A创建一个clusterNode；
   
   ④**B返回PONG给A；**
   
   ⑤**A收到PONG就会发送一次PING；**
   
   ⑥**B收到PONG回送PONG；**
   
   ⑦**A将B的信息群发给集群中的其他节点，然后集群中的其他节点与B握手；**
   
2. **槽指派**

   **这里很重要！我们直到，redis集群是通过分片的方式来存储key-value的，整个数据库被分为16384个槽，每一个key-value都存在着16384个槽中的其中一个，每个节点可以处理0个或16384个key-value；**

   （为什么是16384，其实是因为2048字节=>2048\*8=16384，2048字节有16384个bit）

   每一个节点都有一个大小为2048K的二进制数组，可以直到这个节点是否负责某一个槽；

   集群中的节点会互相通知对方自己负责什么范围的槽（slots），收到信息之后可以将这个信息保存到对应的clusterNode上面，这样集群中所有节点都直到槽的分配了；

   下图是redis集群执行一个命令时候的流程图：

   ![](img/redis46.png)

   1. **那么如何计算key属于那一个槽呢？**

      slot_number=CRC16（key）%16383，这里的CRC16（key）计算key的检验和，然后对16383取模，结果就是这个key所在的slot的编号；

      在重新分槽的时候有可能会遇到ASK错误，这个错误与MOVED类似，都是让客户端的请求重定向到指定的节点；区别在于：**MOVED错误会使得客户端以后查询这个key都到指定的节点，ASK错误只会使客户端在这一次查询的时候到指定节点，因此ASK错误是槽重新分配时候查询key出现的；**

   2. **复制与故障转移**

      一般会有若干个节点共同负责16384个槽，这其中的每一个节点都可以拥有若干个从节点；这些从节点会复制各自的主节点，当主节点挂了就会升级为主节点；

   3. **下线检测**

      集群中的每个节点都会周期性地向集群中的其他节点发送PING命令，如果没能及时收到PONG，就标记为**疑似下线（PFAIL）**；同时还会周期性地跟集群中的其他节点交换节点信息表，如果**超过半数节点认为节点A疑似下线**，那么A就会被标记为**下线（FAIL）**。

      然后A节点的某一个从节点就会变成主节点，并**群发一个PONG，表示自己升级为主节点了**；

      **选举过程**

      ①每一个主节点，在每一个纪元有一次投票机会，**一次故障转移会使得纪元+1**；

      ②从节点发现自己的主节点下线了，就群发一个消息；

      ③收到这个消息的主节点会**回送一个信息给第一个发信息给它的人**，其他忽略；

      ④收到最多回信的从节点就会成为新一个主节点；



### 发布与订阅

1. 订阅与退订

   客户端通过SUBSCRIBE "xxx"来订阅xxx频道；

   在Redis中，**通过一个字典来保存订阅关系，key为频道名称，value是一个链表，表示订阅了这个频道的客户端**；

   ![](img/redis47.png)

   客户端通过UNSUBSCRIBE “xxx”来退订一个频道；

   这个就是反向操作了，如果一个key的链表是空的，那就删除这个频道；

2. 信息推送

   通过PUBLISH "channel" "msg"向channel频道发送msg；





### 事务

这就是类似于mysql的事务，要么一次完成，要么回滚；通过MULTI开启一个事务，通过EXEC来执行，例子：

![](img/redis48.png)

**注意**，在MULTI后面的命令只是**加入执行队列**，只有EXEC指令之后才会依次执行；

redis的队列使用数组实现，每个元素包括指令的函数地址、参数、参数数量；

1. **WATCH命令**

   WATCH是一个**乐观锁**。作用是监控若干个key，如果事务EXEC的时候**至少一个key已经被修改过了**，那就直接不执行事务内容，返回空；**要在MULTI之前对key进行WATCH，否则就没什么意义了**；

   watch的实现与订阅类似，redis有一个专门记录watch的字典，字典的key就是监控的key，value是一个链表，表示哪些客户端在监控这个key；

   **当执行会修改数据库内容的执行时**，首先护检查这个客户端监控的key有没有改变，有的话将REDIS_DIRTY_CAS打开，说明这个客户端不安全，拒绝这个客户端要执行的事务；

2. **ACID**

   这里跟mysql一样，就是**原子性、一致性、隔离性、持久性**；





### lua脚本

暂时跳过





### 排序

redis的SORT可以对**列表建、集合键、有序集合键**进行排序；

1. 对列表进行排序

   ①生成一个与列表等长的数组，元素是redis内置的排序实例；

   ②将每一个数组元素转换为double，浮点数，按照从小到大排序；

   ③按照刚才生成的浮点数开始遍历，返回排序结果；

2. ALPHA

   通过SORT fruits ALPHA可以对字符串数据进行排序

3. ASC、DESC

   顾名思义，可以返回正序和逆序结果；

4. BY

   SORT fruits BY \*-price

   那么排序所用的judge，就会变成value-price这个字符串的转换值，这里不一定按照字母的顺序；

5. LIMIT

   通过SORT fruits LIMIT a b返回**下标a开始返回b个结果**；跟mysql的limit a，b一样；

6. GET

   是一个套娃操作。例如

   SET “a-price” 66

   SORT fruits ALPHA GET \*-price

   这个fruits里面的a元素就会被组合成a-price，最终会返回66；

7. **STORE**

   可以理解为持久化，SORT只是临时排序而已，使用

   SORT a ALPHA STORE b

   可以将排序后的a存储为b；







### 二进制位数组

1. SETBIT

   SETBIT x 0 1，表示将二进制数组x的第0位置1，也就是00000001；

   首先会检查SDS的字节数是否大于等于num/10+1，**不够长会自动扩容**；然后先将旧的值保存，然后将num为设置为x，最后**返回旧的值**；

2. GETBIT

   GETBIT x 0，获取二进制数组x的第0位，返回1；

   由于一个字节为8位，所以如果GETBIT x 10，会首先计算10/8=1，表示在下标为1的字节中，然后10%8+1=3，在下标为1的字节中的第3个位；

3. BITCOUNT

   BITCOUNT x，统计x中有多少个1，返回1；

   **底层实现很神奇**----汉明重量（hamming weight）和查表

   ①汉明重量

   ![](img/redis49.png)

   通过分组统计的方式计算出1的数量；

   ②查表，首先将00000000~11111111包含的1的数量存在一个表里面，然后将二进制数组8位8位取数去查表；

   **redis会根据需要查询的长度自主选择算法，大于128位用SWAR、小于128位用查表**；

4. BITOP

   支持二进制数组间**与、或、非、异或**运算，

   BITOP AND and-result x y，将x和y按位与，返回结果；

5. 底层实现

   底层实现是SDS，就是**字符串对象**；redis的SDS是二进制安全的，所以直接用来表示二进制数组即可；

   在底层实现中，如果BIT[i]的值分别为1100，则**存储位逆序**，存储顺序为0011；

   **为什么会逆序保存？**

   因为逆序保存可以在扩容之后不移动原来的二进制位，降低CPU消耗；

   正序：

   原本是0100 1101；我们执行SETBIT 12 1；

   **扩增是在头部扩增**，变成0001 0000 0100 1101；

   这样需要把之前的二进制位全部往后移；

   逆序：

   原本是1011 0010；我们执行SETBIT 12 1；

   **扩增是在尾部扩增**，变成1011 0010 0000 1000；

   效率极高；





### 慢查询日志

慢查询日志用于记录执行时间超过给定时长的命令，用户可以通过慢查询日志对redis进行优化

这个慢查询的阈值可以通过设置slowlog-max-len来控制；

![](img/redis50.png)

慢查询日志的数据结构是**链表**，这样方便使用头插法新增，且没有大小限制；





### 监视器

通过执行MONITOR命令，**客户端会转换为一个监视器**，服务器接收到的每次命令都会转发给所有的监视器；

![](img/redis51.png)

底层实现为：客户端将自己的monitor标志位打开，服务端每次执行完任务就会将结果发送给所有打开monitor的客户端；









