## 数据结构与对象

### 简单动态字符串

1. simple dynamic string，简称SDS，是一个C语言实现的智能扩增的字符串类；

2. struct sdshdr{

   int len；//保存字符串的长度

   int free；//记录buf未使用的字节

   char buf[]；//用于保存字符串

   }

3. 空间预分配：

   ①如果长度小于1MB，就会分配两倍的空间；

   ②如果长度大于1MB，就会分配请求的空间+1MB的空间；

4. 惰性空间释放：

   SDS在字符串缩短之后，不会立刻将空间重新resize，而是存储在free里面，后续可能还会用到，所以先保存着；如果有需要，可以强行收回空间；

5. **二进制安全**

   由于SDS是根据len属性来判断字符串是否为空，所以及时是二进制数据，比如‘\0’都可以保存，还可以正常读出。

6. 总结：

   ![](img/redis1.png)

7. API

   ![](img/redis2.png)





### 链表

1. struct listNode{

   void \*value;//值

   struct listNode \*prev;//前置节点

   struct listNode \*next;//后置节点

   }

2. 上面的是listNode，这个是list的结构

   struct list{

   listNode \*head;//头结点

   listNode \*tail;//尾节点

   unsigned long len;//链表长

   void\* (\*dup)(void \*ptr);//阶段复制函数

   int (\*match)(void \*ptr,void \*key);//节点值对比函数指针

   void (\*free)(void \*ptr);//节点释放函数指针

   }

3. API

   <img src="img/redis3-1.png" style="zoom:75%;" />

   <img src="img/redis3-2.png" style="zoom:75%;" />





### 字典

是一种保存key-value的抽象数据结构

1. ![](img/redis4.png)

   这个table连接着一个**哈希表**，这个哈希表的长度为size，可以理解为hashtable[size]；

2. 哈希表的节点：

   ![](img/redis5.png)

   可以看到，这里的next**指向下一个哈希表**，其数据类型为dictEntry；

3. **字典的两个结构体：**

   ![](img/redis6.png)

   ![](img/redis7.png)

   type和privdata是为了创建多态字典而设置的，privdata的结构体如上所示；

4. ht里面包含了两个哈希表，正常情况下只会使用0号哈希表，**进行rehash的时候才会使用1号哈希表**，平时1号哈希表就是空的；

5. redis使用**链地址法解决冲突**。每一个key-value都会用一个节点保存起来，如果发生冲突，使用next指针拉起一个链表。

6. **rehash操作**

   为了将负载因子保持在合理范围，在数据太多或者太少的时候需要进行rehash

   负载因子的计算方法：loda_factor=ht[0].used/ht[0].size；

   负载因子大于等于1的时候扩展，小于等于0.1的时候收缩；

   **万一在rehash的时候进行查询怎么办？**

   为了防止这种情况，rehash是渐进式的，不是阻塞执行的，其步骤为：

   ①首先根据ht[0].used获取键值对的数量；如果是扩展，ht[1]的大小为2^n，其大小刚好大于ht[0].used\*2；如果是收缩，ht[1]的大小为2^n，其大小大于等于ht[0].used；

   ②在字典中维持一个rehashidx=0，表示rehash正式开始；这个值表示已经rehash成功的元素的个数，当全部完成，rehashidx=-1，表示rehash结束；

   ③将ht[0]上的键值对重新计算哈希值和索引值，rehash到ht[1]里面；

   ④rehash完毕之后，释放ht[0]，将ht[1]转移到ht[0]；ht[1]创建一个空表，为下次rehash做好准备；

   ⑤在rehash过程中，**查询**先在ht[0]进行，失败再到ht[1]；**新增**只会在ht[1]中执行；**删除和更新**会两个表同时进行；

7. API

   ![](img/redis8.png)



### 跳跃表

是一种数据结构，支持平均查找时间O（logN），最坏O（N）的查找。

1. 其实现：

   ![](img/redis9.png)

   **跨度**表示前进指针到达的两个节点之间的距离，用以计算目前到达的节点的下标；

   **后退指针**可以理解为双向链表的prev，不能跨越多个节点，只能逐个回退；

   **分值**是一个double类型的浮点数，跳表中的所有节点都按照分值升序排列，**多个节点分值可以相等**；

   **成员对象**一般就是一个SDS，**多个节点的成员对象必须唯一**；

2. 上面是跳跃表的节点，下面是跳跃表：

   ![](img/redis10.png)

3. 一个跳表的示意图

   ![](img/redis11.png)

4. API

   ![](img/redis12.png)





### 整数集合

如果一个集合只包含整数，且元素不多，redis就会选择整数集合来保存

1. 整数集合intset的结构体：

   ![](img/redis13.png)

   整数集合里面不会存在重复的元素。length就是contents的长度，contents用来存储整数；

   encoding表示存储的数据的类型，如果是INTSET_ENC_INT16那就是16位整数，还有很多，下面是一个示意图：

   ![](img/redis14.png)

   由于**每个元素的大小为64位，所以总的长度为64\*4=256位。**

   即使只有一个元素需要64位存储，其他的元素类型必须统一，所以这里肯定是取最大的一个类型；

2. **升级**

   当新添加的一个元素的长度超过了encoding，那就要升级了，步骤为：

   ①根据新的类型分配足够的新空间；

   ②所有元素的类型都要转换为统一类型，然后放置在应该在的位置（根据它当前的下标乘以升级后的长度），有序性不变；

   ③将新的元素插入这个整数集合；

3. **降级**

   目前不支持降级，升级之后，这个整数集合的encoding不会下降；

4. API

   ![](img/redis15.png)





### 压缩列表

压缩列表是列表建和哈希键的底层实现之一。

1. 具体结构

   ![](img/redis16.png)

   这里的zlbytes表示整个列表的长度，zltail指向最后一个节点；

2. 压缩列表里面entryN，也就是节点的构成：

   1. previous_entry_length：前一个节点的长度，**用来访问前一个节点**；
   2. encoding：表示这个节点保存的数据类型；
   3. content：实质的内容是什么，就看这个content了；

3. API

   ![](img/redis17.png)







### 对象

这个很熟悉了，就是面向对象里面的对象，很重要

1. 对象的结构：

![](img/redis18.png)

2. 类型：

   ![](img/redis19.png)

   **对象的键总是字符串**，其值为上述的类型之一，我们所说的“字符串键”是指存储的值类型为字符串；

3. 编码和底层实现：

   底层实现指向数据结构，编码表征这个底层实现的具体实现。

   **type msg是查看msg的类型；object encoding msg是查看msg的编码；**

   例如：

   set msg “hello world”

   type msg 返回string

   object encoding msg 返回embstr；

4. 字符串对象：

   一般分为int、raw、smbstr；

   ①如果值为整型，那就是int；

   ②如果是很长的字符串，那就是raw；

   ③如果是短字符串或者浮点数，那就是smbstr；

5. 字符串的一些操作：

   ![](img/redis20.png)

6. 列表的一些操作：

   ![](img/redis21.png)

7. 哈希表的一些操作:**哈希表的底层实现为ziplist或者hashtable**

   ![](img/redis22.png)

8. 整数集合对象的操作：**整数集合的底层实现为intset或者hashtable**

   ![](img/redis23.png)

9. 有序列表：**有序列表的底层实现为ziplist或者skiplist**

   ![](img/redis24.png)

   跳表的底层实现包含**一个跳表和一个字典**。

   使用跳表的好处是**元素存储是有序的，可以以O（1）实现范围性的操作**；但是按照键随机访问就需要O（N）；

   使用字典可以按照键达到O（1）的访问，但是由于数据是无序存储的，所以基于范围性的操作要先排序然后再做；

10. **Redis中的命令多态**

    1. del、expire、rename、type、object这些命令**可以对任意键执行**，这是一种**基于类型的多态**；
    2. sadd、spop等只能对集合键执行，但是其底层实现有两种，这也是一种**基于编码的多态**；



### 一些比较重要的概念

1. **内存回收！**

   通过对对象**构建一个引用计数**，在适当的时候自动释放对象；这不就是C++里面的智能指针shared_ptr要做的事情吗？

2. **对象共享！**

   如果A集合已经存在一个对象为整数100，然后B集合也需要一个整数100，那么**A和B会共享这个对象，这个对象的引用计数+1**；

   服务器启动的时候，会自动创建0~9999的字符串对象；然后需要的时候直接共享这些对象就行；

   如果你set A 100，然后object refcount A会返回2，说明这个A只是引用了服务器启动创建的那些对象而已；

3. **对象的空转时长！**

   对象里面还有一个属性：lru，就是最近最长时间没访问的意思？该属性**记录了对象最后一次被访问的时间；**

   可以使用object idletime X来访问对象X的空转时长；





## 单机数据库的实现

### 数据库

1. 在redis.h/redisServer里面保存着一个redisDb的数组，这个数组里面是很多的数据库；还有一个属性dbnum表示redisDb里面数据库的数量，dbnum的值由服务器配置的database选项决定，默认值为16；

2. **默认使用的是0号数据库**，也就是平时我们随便set A 100就是在0号数据库；可以使用select n来切换到n号数据库，当时get A 就是一个（nil）了；redis服务器和客户端对数据库的使用可以由下图所示:

   ![](img/redis25.png)

   其实我们使用select就是改变指向客户端的db而已，server的db是没有变的；

3. **数据库键空间**

   **redis是一个键值对数据库服务器**。使用了一个dict来保存所有的键值对，这个dict就是键空间；

   下面是一个形象的例子：

   ![](img/redis26.png)

   ![](img/redis27.png)

   可以看到，**dict里面保存了很多的对象**，对象的键是字符串，例如message、alphabet；这个对象的值就看具体的实现了，可以是字符串、列表、哈希表、集合、有序集合五种其中之一；

4. 一些基本操作：

   1. 新增键值对：

      set msg “hello”或者rpush number 1 2 3 6等都是可以的；

   2. 删除键值对：

      del msg或者del number；

   3. 更新键值对：

      就是再次使用新增键值对的命令，会直接覆盖掉；如果对应的键**类型不同**，例如将哈希表更新为字符串会报错，这个时候先del删除掉，再重新操作；

   4. 对键取值：

      各有不同，例如字符串就是get；列表就是lrange等等；

5. **进行查询时的一些维护操作**

   1. 服务器维护了查询是否命中的计数，分别是keyspace_hits（命中次数）和keyspace_misses（未命中次数），可以使用info stats查看；
   2. 使用flushdb可以情况整个数据库；当数据库不为空，可以使用randomkey返回随机一个键；
   3. 对于查询过的键，更新其lru属性，可以使用object idletime X来查看X的上次访问距离当前的时间；
   4. **如果读取一个键已经过期了，就先删除这个键，然后执行剩余的操作；**
   5. 如果使用watch监视某个键，修改这个键之后就标记为dirty，用于事务程序中；
   6. 服务器每次修改一个键，就会对dirty键+1，会**触发服务器的持久化和复制操作；**
   7. 如果开启了数据库通知，对键的修改会发出通知；

6. **设置键的过期时间**

   使用expire和pexpire来控制某个键的过期时间，过期之后这个键就会被删除；

   例如：

   ![](img/redis28.png)

   这里的expire表示秒，pexpire表示毫秒；

   可以使用time获取当前的UNIX时间戳，用以设置具体的过期时间戳；

   如说使用**ttl X**可以获取X距离过期剩余的时间，pttl返回的是毫秒精度的时间；

   ![](img/redis29.png)

   这里的expireat表示过期时间设置为timestamp时间戳格式，要配合time命令使用；

   一共有四种设置过期时间的命令：

   1. expire：精度为秒；
   2. pexpire：精度为毫秒；
   3. expireat：时间戳模式，精度为秒；
   4. pexpireat：时间戳模式，精度为毫秒

   其实只有4.pexpireat是设置过期命令的，其他三种都是进行转换然后调用它；

   具体关系为：

   ![](img/redis30.png)

7. 保存过期时间

   redisDb结构的expires字典保存了所有键的过期时间；expires字典里面的键指向对应的键值对的地址，值表示这个键值对的过期时间戳；

8. 删除过期时间

   persist命令是expire的反命令，其实现就是在expires字典里面删除对应键的过期时间戳；

   例如：

   persist X就会将X的过期时间删除，这样X就会永久存在了；

9. 返回过期时间：

   通过ttl X返回X距离过期还有多少秒；pttl返回毫秒；

   返回值为-1表示该键没有设置过期时间；

   返回值为-2表示该键不存在于数据库；

10. **过期键的删除策略**

    一般来说，一共有三种策略（**并不是说redis就是这样的策略**）：

    1. 定时删除：主动删除策略，**创建一个定时器，当到达指定时间的时候，删除对应的键；**好处是删除速度最快，对内存很友好；缺点是对CPU时间不友好，Redis服务器中的时间事件是一个无序链表，查找复杂度为O（N），如果有大量的时间事件，会创建大量定时器，消耗CPU资源；
    2. 惰性删除：被动删除策略，只有我们访问对应键的时候才检查是否过期，如果过期了就删除，否则就返回结果。好处是对CPU友好，如无必要，绝对不占用CPU资源；缺点是对内存不友好，如果长时间没有访问，内存中充斥着大量的过期键值对，可以理解为内存泄漏。
    3. 定期删除：主动删除策略，定期检查一遍键值对，删除过期的键值对。是定时删除和惰性删除的折中方案，但是删除时间间隔太长就变成了惰性删除，间隔太短就变成了定时删除，这个间隔比较难把握；

    Redis的删除策略：

    **使用惰性删除+定期删除两种策略。**

    1. 惰性删除的时间点就是在我们访问数据库对应键值对的时候，调用expireIfNeeded判断是否过期，过期则删除，未过期则继续执行；
    2. 定期删除的时间点在服务器周期性执行serverCron的时候调用函数activeExpireCycle，从一定数量的数据库中**随机**取一定数量的键检查是否过期，如果检查的途中中断了，会根据全局变量current_db继续刚才检查的数据库；

11. **AOF、RDB的复制功能与过期键**

    1. 调用save或者bgsave的时候会生成rdb文件，保存的时候会检查整个数据库里面所有的键，如果这个键已经过期了，那就不会加入到rdb文件；
    2. 从rdb载入的时候，同样会检查里面的键，过期的键不会被载入；**仅针对主服务器模式，如果是从服务器模式不管过不过期会全部载入；**
    3. 服务器以AOF持久化模式运行时，某键还没有删除的时候，不会有影响；当该键过期被删除的时候，**会在AOF文件中追加一个del命令显示说明删除该键**；对AOF重写的时候就不会写入过期数据了；

    ### 复制

    1. 当服务器运行在复制模式时，主服务器删除某键，**会群发一个del命令让从服务器删除该键；**从服务器只受主服务器控制，如果客户端访问从服务器，即使那个键过期了，一样可以返回，并且不会删除；

12. **数据库通知**

    客户端通过订阅给定的频道或者模式，来获取数据库中的变化，以及数据库中命令的执行情况；

    有两种模式：

    1. **订阅一个键，返回在该键执行的操作**，关键字为keyspace：

       ![](img/redis31.png)

    2. **订阅一个操作，返回该操作执行的键**，关键字为keyecent：

       ![](img/redis32.png)

    3. 通知功能的实现原理：

       服务器设置notify-keyspace-events选项表示了发送哪一类通知：

       1. AKE：所有的通知；
       2. AK：所有的keyspace通知；
       3. AE：所有的keyevent通知；
       4. K$：只发送关于字符串键的keyspace通知；
       5. EL：只发送关于列表的keyevent通知；

       在服务器执行某个操作成功之后，会调用notifyKeyspaceEvent，传入操作的类型（分为keyspace和keyevnet）、命令名称、对应的对象等信息；

       ①首先检查服务器是否允许发送该通知；

       ②然后检查是否允许发送对应事件的类型以及键，如果允许就发送，否则直接return；





### RDB持久化



