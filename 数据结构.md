## 绪论

1. 数据结构的三要素：**逻辑结构、物理结构、数据的运算。**
2. 算法的五个特征：**有穷性、确定性、可行性、输入、输出。**



## 线性表

1. 线性表是具有**相同数据类型**的n个元素的**有限**序列。
2. 顺序表的逻辑顺序与物理顺序相同（存储在一块连续的内存当中），**支持随机访问，插入和删除操作需要移动大量元素，适合需要频繁查找的数据。**
3. 单链表是用任意的内存单元来存储一组元素的数据结构，一般含有一个**访问后驱节点的指针**next。**单链表不支持随机访问，插入和删除操时间复杂度作为O（1），适合需要频繁修改的数据。**
4. 双链表在单链表的基础上添加了一个**访问前驱结点的指针**，仍然不支持随机访问，但是比单链表更灵活。
5. 循环单链表和循环双链表是指**最后一个节点的后驱指向头结点**的链表。
6. 静态链表：是基于数组实现的，**存储空间为一块连续的内存**，其元素带有表示下一个元素的下标，因此插入和删除都是O（1）。



## 栈和队列

1. 栈是指只允许在**一端**插入和删除的线性表。分为**顺序栈、链栈、共享栈。**

   链栈：用**单链表**实现的栈，头结点充当top指针，插入和删除都只能从头结点进行；

   共享栈：两个顺序栈**共享**一个一维数据空间，st1的top指向0，st2的top指向size-1，栈的生长方向是相对的，当st1==st2的时候栈满。

2. 队列是只允许**在一端插入而在另一端删除**的线性表。

3. 循环队列是逻辑结构为环形的队列，队头指向队列第一个元素，队尾指向队列下一个元素插入的位置。**为了区分队空还是队满，有一个存储单元是不能使用的。**因此，当队头==（队尾%size）时队列为空，当（（队尾+1）%size）==队头的时候队满。

4. 链式队列就是两个指针一个队头一个队尾。

5. 双端队列：两端都可以插入或删除的队列，有些受限的双端队列只有一段可以插入和删除，另一端只能插入或删除。



## 树与二叉树

1. 树是一种递归、分层的数据结构，有两个特点：

   ①根节点**没有**前驱结点，除根节点外所有节点**有且只有**一个前驱节点；

   ②树中所有节点可以有零个或多个后继节点；

2. 树具有以下四个基本性质（**度数m==2就是二叉树**）：

   ①树的节点数等于所有节点的度数（边的数目）+1；

   ②度为m的树中第i层上至多有m^（i-1）次方个节点；

   ③高度为h的m叉树至多有（m^h-1）/（m-1）个节点；

   ④具有n个节点的m叉树最小高度为logm（n（m-1）+1）下取整；（就是求上面那个公式的h）

3. 二叉树就是度数m==2的树：

   1. 满二叉树：高度为h，含有2^h-1个节点的二叉树称为满二叉树；
   2. 完全二叉树：满二叉树的特殊版本，**只有最后一层缺失节点，缺失孩子的那个节点的左边是满的，右边全是空的**，这就是完全二叉树；
   3. 二叉排序树：左子树中所有节点均**小于**当前节点，右子树中所有节点均**大于**当前节点，这就是二叉排序树，同时，其左右子树分别都是二叉排序树；
   4. 平衡二叉树：**任意节点**的左子树和右子树的深度只差≤1；

4. 顺序存储的二叉树：如果二叉树使用数组来存储，则**对于第i个节点，其左孩子和右孩子分别是2i和2i+1，并且根节点下标必须为1而不是0**。

5. 链式存储的二叉树有两个指针，分别指向左孩子和右孩子。

6. 二叉树的遍历分为：**先序遍历（先访问节点值，再访问左孩子，最后访问右孩子）、中序遍历（先访问左孩子，再访问节点值，最后访问右孩子）、后序遍历（先访问左孩子，再访问右孩子，最后访问节点值）、层次遍历（从根节点开始按每层从左到右访问节点值）。**

7. 对于上述四种遍历顺序中，**除了先序和后序不能唯一确定二叉树以外**，所有两两组合均可唯一确定二叉树。

8. 线索二叉树：线索二叉树的节点有五部分ltag、lchild、val、rchild、rtag。**当ltag或者rtag==0**，表示该节点**有左孩子或右孩子**；如果为1，则指向当前节点的前驱或者后驱。

9. 普通的树的存储结构：

   1. 双亲表示法：采用连续空间存储每个节点，每个节点有一个元素对应父节点的下标；
   2. 孩子表示法：为n个节点各维护一个链表，存储其对应的孩子节点；
   3. 孩子兄弟表示法：左节点指向第一个孩子节点，右节点指向兄弟节点；

10. 树转换为二叉树：利用孩子兄弟表示法转换。

11. 森林转换为二叉树：先将每一棵树转换为二叉树，然后选择其中一棵的根节点右节点指向另一棵的根节点，另一棵的根节点的右节点指向另另一棵的根节点，以此类推。

12. 二叉树转换为森林为上述过程的逆变换。

13. 树的遍历一般分为**先根遍历（相当于二叉树的先序遍历）和后根遍历（相当于二叉树的中序遍历）。**

14. 平衡二叉树（AVL）是**特殊的二叉排序树**，是为了克服极端情况下查找效率变差的问题。

15. **哈夫曼树**是带权路径（WPL）最小的二叉树，也称为最优二叉树。其构造方法为：

    ①选择权值最小的两个节点组成二叉树，将其权值之和即此时的根节点加入候选节点；

    ②每次合并两个节点，直到最后生成一棵树；

16. **哈夫曼编码**是哈夫曼树的应用，如果左节点代表0，右节点代表1，就可以对每个叶子节点生成唯一标识的二进制码。



## 图

1. 图由顶点集V和边集E组成，其中E连接两个顶点V：

   ①有向图：如果E是有向边，则为有向图；

   ②无向图：如果E是无向边，则为无向图；

   ③简单图：如果满足**不存在重复边、不存在到自身的边**，则为简单图；

   ④完全图：在**无向图**中，如果任意两个顶点之间都存在边，总共n\*（n-1）/2条边，则称为**无向完全图**；如果是在**有向图**中，任意两个顶点之间都存在边，总共n\*（n-1）条边，则称为**有向完全图**；

   ⑤在**无向图**中，如果任意两个顶点都是连通的，则为**连通图**；无向图中的**极大连通子图**称为连通分量；

   ⑥在**有向图**中，如果任意两个顶点**双向**都是连通的，则为**强连通图**；有向图中的**极大连通子图**称为强连通分量；

2. 图的存储方法：

   1. 邻接矩阵法：

      就是用一个一维数组存储顶点信息，一个**二维数组存储边的信息**。如果是带权图，则矩阵中的值为权值，例如矩阵A中（3，1）为5，代表顶点3到顶点1有一条权重为5的边；

   2. 邻接表法：

      当一个图是稀疏图的时候，邻接矩阵太浪费空间了。给每个顶点维护一个**单链表**，链表中的元素代表该顶点到达此顶点边的权重；

   3. 十字链表：

      是**有向图**的一种链式存储结构。其中顶点节点包含**数据、第一条进入该节点的边、第一条离开该节点的边；**弧节点包含**此弧尾部连接的顶点、头部连接的顶点、下一条尾部相同的边、下一条头部相同的边、数据；**

   4. 邻接多重表：

      是**无向图**的一种链式存储结构。其中顶点节点包含**数据、第一条与连接该节点的边；**弧节点包含**mark（表示此边是否已经检查）、此弧尾部连接的顶点、下一条尾部相同的边、此弧头部连接的顶点、下一条头部相同的边、数据；**

3. **图的遍历**

   1. **BFS广度优先遍历**：类似于二叉树的层次遍历，从顶点v出发，先依次遍历w1、w2等与v有连接的顶点；然后再依次遍历与w1有连接的顶点、与w2有连接的顶点；每个顶点入队一次，时间复杂度O（V），**使用邻接表时**，每条边遍历一次O（E），所以总的时间复杂度是O（V+E）；**使用邻接矩阵时**，时间复杂度为O（V^2）。

      应用1、**单源最短路径问题**：从顶点u到顶点v的任何路径中边数最少的一条；

      应用2、**广度优先生成树**；

   2. **DFS深度优先遍历**：从顶点v出发，先遍历任意一个未访问的连接顶点w1，然后再访问与w1有连接的任意一个顶点，直到没有未访问的边则回退。每个顶点入队一次，时间复杂度O（V），**使用邻接表时**，每条边遍历一次O（E），所以总的时间复杂度是O（V+E）；**使用邻接矩阵时**，时间复杂度为O（V^2）。

      应用1、**深度优先生成树**；

   3. 如果**任意**选择一个顶点，**可以遍历整个图**，则图是连通的，否则图是不连通的。

4. **图的应用**

   1. **最小生成树**：在**带权图**中，若包含所有的顶点且权重之和最小的那棵树，称为最小生成树，具有以下性质：

      1. 当权重全都不一样的时候，树是唯一的；
      2. 最小生成树可能不唯一，但是**权重之和唯一**；
      3. 最小生成树的边数为顶点数-1；

      经典算法

      1. **Prim算法**：任意一个顶点V1加入集合V={V1}开始，找到**与V中顶点有连接的权重最小能到达的顶点**，将连接的顶点V2加入V；以此类推，每次加入一个顶点，直到所有顶点都进入集合V，算法结束。算法每次都去查找顶点V相关的其他顶点，所以不依赖与边，**适用于稠密图，时间复杂度为O（V^2）。**
      2. **Kruskal算法**：将所有的边按权值递增排序，每次**选择权重最小且连接顶点不在V中的一条边**，以此类推直到V中包含所有顶点。通常此算法利用**堆**来存储边，所以每次选择边只需要O（logE），利用**并查集**描述顶点集V，因此总的时间复杂度为O（ElogE）。

   2. **最短路径**：对于**有权图**，任意顶点到达其余各顶点权重最小的路径称为最短路径。

      经典算法

      1. **Dijkstra算法**：

         ①初始化顶点集V里面包含一个出发的顶点，并将顶点集V中与其余所有顶点**直接连接的权重**记录起来，不可达为∞；

         ②选择权重最小的一个顶点加入V，更新表格；

         ③以此类推，直到V包含所有顶点；

         顶点V1到达某一顶点V2的求解时间复杂度为O（V^2），此算法求解所有顶点到任意顶点的距离，所以总的时间复杂度为O（V^3）。**注意，不适用于权重为负的图。**

      2. **Floyd算法**

         ①初始化一个二维矩阵，（i，j）表示顶点i到顶点j的权重，不可达为∞；

         ②假设通过一个中间顶点V1，更新矩阵。例如，（2，3）为∞，此时（2，1）且（1，3）均可达，更新（2，3）为两者之和；

         ③以此类推，直到矩阵不再变化；

         与Prim算法一样，时间复杂度为O（V^3），**适用于权重为负的图，但不允许权重为负的边组成回路。**

   3. **拓扑排序**：一个**有向无环图**，满足**每个顶点只出现一次，如果A在B的前面则不存在B到A的边**，则称此为拓扑排序。

      判断是否是拓扑图的方法：找到一个**只出不进**的顶点，去掉这个顶点出去的所有边；然后继续寻找下一个只出不进的顶点，继续去掉边；如果最后没有边剩余，那就是拓扑图；

   4. **关键路径**：在**带权有向图**中，从入度为0的顶点到达出度为0的顶点，具有**最大路径长度**的路径称为**关键路径**，经过的活动为**关键活动**。

      ①首先，从源点出发，**记录从源点到达每个顶点的最大路径长度**；

      ②然后，从汇点出发，**反向寻找从汇到回到所有顶点的最小路径**，用①中求得的汇点的最大路径长度减去这个最小路径；
   
      ③如果①和②中的值一样，说明那个活动是**关键活动**，他们之间的路径就是**关键路径**。



## 查找

1. 平均查找长度（ASL）是衡量查找算法的最主要指标，计算方法为查找容器中所有值所需要的的次数的平均值。

2. 顺序查找：逐个检查元素，**适用于有序或者无序序列。**

3. 折半查找：每次缩小一半范围，**使用于有序序列。**

4. 分块查找：首先确定元素所在的块，然后在这个块中查找元素；

5. **B树**：又称**多路平衡查找树**，所有结点的孩子结点数的最大值称为B树的阶，B数满足：

   ①每个结点至多有m-1个元素，m棵子树；

   ②若根节点不是叶子结点，则至少有两棵子树；

   ③除根节点以外的所有非叶子结点至少有m/2棵子树；

   ④每个结点中元素**有序**，且两个结点中的子树中的值不会超出这两个元素的范围；

   

   **B树中的查找分为两个步骤：在B树中查找结点，一般在磁盘上进行；在结点中二分查找元素，一般在内存中进行。**

   

   **B树的插入：**B树中的每个结点包含的元素个数有限，所以有时候插入元素后不再符合定义。因此

   ①如果插入后某结点元素过多，则取**该节点的中间值，中间值放到父节点中，然后该结点分裂成两个结点。**一直遍历父节点，如果不符合定义继续分裂，最坏情况下会使得B树高度+1。

   

   **B树的删除**：如果删除元素之后，该节点不再符合规定，则需要调整。①如果要删除节点的**兄弟够借**，则将删除节点的右边界元素移到其位置，然后兄弟节点的最小值代替右边界元素的位置。②**兄弟不够借**，将兄弟节点与删除节点的父节点中的元素合并称为新的兄弟结点。

6. **B+树**：B+树与B树的变形版，有以下特征

   ①B+树中，**结点有n个元素，就有n个子树；**B树中，**结点有n个元素，就有n+1个子树**；

   ②B+树中，非根节点的元素n个数为\[m/2，m\)；B树中，非根节点的元素n个数为\[m/2-1，m-1\)；

   ③B+树中，**非叶结点只含有对应子树的最大元素及对应地址，不包含其存储地址。**

   ④B+树中，所有的叶子结点连成一个链表，该链表**包含所有的元素**，即每个元素在B+树中出现两次，但是非叶结点没有地址，只有叶子结点有对应元素的地址。

   **B+树查找：**分为两种，第一种是直接从最小元素开始查找；第二种是从根节点开始二分查找；

7. **Hash哈希表**：

   1. 散列函数是把一个关键字映射成关键字对应地址的函数；

   2. 散列函数有可能把两个不同的关键字映射到同一个地址，称为**冲突**；

   3. 散列函数构造方法：

      1. 直接定址法：使用H（key）= a\*key+b的形式映射，**不会发生冲突**；
      2. **除留余数法**：最常用的方法，使用H（key）= key % p；
      3. 数字分析法：利用不同进制数中，各个数码出现的概率来选取散列地址；
      4. 平方取中法：取关键字的平方值的中间几位作为散列地址；
      5. 折叠法：将数字分成位数相同的几部分，然后将这几部分进行叠加；

   4. **处理冲突的方法：**

      1. 开放定址法：指空闲地址既对其同义词开放也对其他元素开放。
         1. 线性探测法：当发生冲突的时候，顺序查看下一个单元，直到找到一个空闲位置进行插入，会使得**元素聚集**，降低查找效率；
         2. 平方探测法：发生冲突时，将结果加上1^2、-1^2、2^2、....，是比较好的方法，但是无法覆盖所有的单元；
         3. 再散列法：H（H0+i\*H2（key））%m，初始的i==0，此时为正常映射，如果发生冲突，i++，知道找到空闲位置；
      2. 拉链法：对于每一个单元维护一个单链表，发生冲突则插入链表尾部。

   5. 字符串模式匹配----**KMP算法**

      给定字符串S1和字符串S2，在S1中查找是否存在S2，一般的做法是需要不断回溯的，很多元素可能被检查很多次，效率很差。KMP算法的**主串S1是不需要回溯的**，通过标记S2的前缀信息，达到快速检索。

      具体内容请自行百度。



## 排序

1. 对于容器中的相同元素v1和v2，如果排序前v1在v2前面，排序后v1仍然会在v2前面，则算法是**稳定的**，反之是不稳定的。

2. 插入排序

   1. 直接插入排序：一种**稳定**的排序算法，时间复杂度为**O（n^2）**。

      ①长度为n的数组L，查找出L[i]在（1，i-1）中的位置k；

      ②将（k，i-1）的数字全部往后移动一个位置；

      ③移动前将L[i]存储在L[0],移动后复制L[0]到L[k];

   2. 希尔排序：一种**不稳定**的排序算法，时间复杂度为**O（n^2）**。

      ①先取一个小于数组长度n的步长d1，把数组中按照步长分为d1个组（例如d1==2，则0、2、4、6、...为一组，1、3、5、...为另一组）；

      ②在各组中进行直接插入排序，直到di==1，就是最后一次排序；

3. 交换排序

   1. 冒泡排序：一种**稳定**的排序算法，时间复杂度为**O（n^2）**。

      ①假设要按照升序排序，从0开始，每次比较i和i+1的元素，如果是逆序则交换，然后i++；

      ②因此**每次会确定一个最大元素的最终位置**；

   2. **快速排序**：一种**不稳定**的排序算法，时间复杂度为**O（nlogn）**。

      ①选择其中一个元素pivot，把比这个元素小的数放在左边，比他大的数放在右边；

      ②因此，每次都会**确定pivot的最终位置**；

4. 选择排序

   1. 简单选择排序：一种**不稳定**的排序算法，时间复杂度为**O（n^2）**。

      ①每次从数组中选择最小的一个元素跟L[0]交换，然后以此类推；

      ②每次能**确定一个最小元素的位置**；

   2. **堆排序**：一种**不稳定**的排序算法，时间复杂度为**O（nlogn）**。

      ①以小顶堆为例，小顶堆即根节点是最小的；

      ②某结点的序号为i，其孩子结点为2i和2i+1，小顶堆中，要求i的值小于2i和2i+1；

      ③排序后数组中依然不是有序的，但是在堆里面是有意义的；

5. 归并排序：一种外部排序，即并非所有元素都在内存，还有些在硬盘。

   一种**稳定**的排序算法，时间复杂度为**O（nlogn）**。

   ①将每个元素单独作为一组，然后与相邻的一组有序合并成一组，此时每组有两个元素；

   ②继续合并响铃的组，此时每组有四个元素；

   ③以此类推，直到所有元素合并成一组；

6. 基数排序：一种**稳定**的排序算法，时间复杂度为**O（d（n+r））**，其中d为元素的位数，n为元素个数，r为当前进制的值。（跟桶排序有点类似）

   ①例如当前是十进制，全是三位数元素；

   ②从个位开始，按照所有元素的个位的数字按照0-9分成10个队列，然后从0-9的顺序收集这10个队列；

   ③然后在十位，最后到百位，以此类推；

   

   

   