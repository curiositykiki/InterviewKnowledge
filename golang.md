### 入门

1. 可以通过转义字符：%v输出自然类型值、%t输出布尔值、%T输出变量类型；



### 程序结构

1. 一个名字必须以**一个字母或者下划线**开头，并且有个特点：**首字母的大小写决定了该变量或者方法在包外是否可见**；例如Printf是fmt包里面的函数，因为是大写开头所以我们可以在包外访问；如果是printf则只能在包内访问，包外是无法使用的；

2. **go的自动垃圾回收器：**不同于C、C++，go是有垃圾回收（GC，Garbage Collection）机制的；

   旧版的mark-sweep方式：分为mark和sweep两个过程，在某一时刻先**暂停所有的活动（标记的时候不希望有新增的对象）**，然后从堆栈的根节点开始扫描，对于能访问的对象标记为可达；然后程序恢复运行，然后会**启动一个goroutine**进行sweep操作，对所有不可达的对象进行清除；

   新版的三色标记法：黑色代表活跃对象，灰色代表未扫描的活跃对象，白色代表不活跃对象；首先**暂停所有的活动**，然后从堆栈的根节点出发，将所有相连的对象标记为灰色，然后启动一个**写屏障（一般来说黑色是不允许连接白色节点的，因为黑色节点已经扫描完毕了，清除的时候白色节点就拜拜了；但是用户有可能会这么操作，因此对于黑色、灰色引用的白色节点，同一变成灰色，那就不会被清除了，同时还可以扫描与之相连的对象）**，然后不断遍历灰色对象，将与灰色对象相连的对象标记为灰色，然后自身会变成黑色；然后会请求**暂停所有活动**，然后清除白色对象；

3. go中可以重新定义不同的类型，但是**即使底层是同一类型**，重新定义后也是不同的类型；

   type A float64;

   type B flost64;

   则A=B会报错；





### 基础数据类型

1. GO语言除了整数、浮点数以外，还提供复数；根据精度可分为complex64和complex128

   var x complex = complex(1,2) //1+2i

   var y complex = complex(3,4) //3+4i

   fmt.Println(x\*y) //-5+10i

   fmt.Println(real(x*y)) //-5

   fmt.Println(imag(x*y)) //10

2. 字符串可以使用**切片**，跟python类似；

   s:="hello"

   fmt.Println(s[2:]) //llo

3. 常量，运行期间不能被修改的值，但是定义方式比较特殊：

   const(

   ​	pi = 3.14

   ​	TAG = "hello world"

   )

   **常量的编译是在编译期完成的；**



### 复合数据类型

1. 数组：**固定长度**的装有特定类型的序列；由于无法伸缩，所以很少用，取而代之的是切片
2. 切片（slice）：**动态增长和收缩**的序列；一个slice由三个部分组成：**指针、长度、容量**；其底层**引用了一个数组对象**；指针指向slice的第一个元素，但不一定是数组的第一个元素；多个slice可以共享一个数组；声明slice（i，j）其下标范围是**左闭右开**的；如果检索范围**超过slice底层数组的长度，即cap**，会引发panic；如果只是超过切片长度，切片会变长；