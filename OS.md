## 概述

1. 操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以**提供给用户和其他软件方便的接口和环境的程序集合**。

2. 操作系统的基本特征包括**并发、共享、虚拟、异步，其中并发和共享是最基本的特征。**

3. 并发：是指**同一时间间隔**内发生的多个事件，并行是指**同一时刻**发生的多个事件。例如，单处理机的情况下，**分时**可以实现并发；多处理机情况下，**同一时刻**运行可以实现并行。引入进程的目的就是为了实现并发。

4. 共享：分为**互斥共享**和**同时访问**两种方式，临界资源需要互斥共享。

5. 虚拟：利用多道程序设计技术，把一个CPU虚拟为多个逻辑上的CPU称为**虚拟处理器；**

   ​			利用物理存储来扩增内存称为虚拟内存；

   ​			总的来说虚拟分为**时分复用技术**和**空分复用技术**。

6. 异步：在多道程序环境下，允许多个程序并发执行，但是每一个程序都不是**一气呵成**，而是断断续续，这就是进程的异步。

7. 操作系统应该具有**处理机管理、存储器管理、设备管理和文件管理。**

   1. 处理机管理

      处理机的分配是以**线程**为基本单位。进程管理的主要功能：**进程控制、进程同步、进程通信、死锁处理、处理机调度；**

   2. 存储器管理

      主要功能：**内存分配、地址映射、内存保护与共享、内存扩充；**

   3. 设备管理

      主要功能：**缓存管理、设备分配、设备处理、虚拟设备；**

   4. 文件管理

      主要功能：**文件存储空间管理、目录管理、文件读写管理与保护；**

8. 操作系统提供两类接口：**命令接口和程序接口。**命令接口可以分为**联机控制方式**，通过cmd输出操作命令；**脱机控制方式**，使用脚本。程序接口即**系统调用命令**，用户使用这些指令控制操作系统。

9. 由于单道批处理系统存在**高速CPU由于等待低速的I/O导致吞吐量低的缺点，**所以设计了**多道批处理系统**。多道批处理系统宏观上式并行的，即多到程序都在运行；微观上式串行的，即轮流占有CPU。缺点是**用户响应时间长，不提供人机交互能力。**因此发展出了**分时操作系统**，即把CPU的运行时间分为很短的时间片，按时间片轮流分配给作业。

10. CPU执行两种不同性质的程序：**操作系统内核程序**和**用户应用程序**。如**I/O指令、中断指令、寄存器存取等**指令都属于内核程序的指令，**用户程序不能直接调用。**操作系统在实现上划分了**用户态**和**内核态**来区分。

11. **内核**一般包括：**时钟管理、中断机制、原语（原子操作）、系统控制的数据结构及处理**。

12. 从用户态进入内核态的途径是**中断（外中断）和异常（内中断）。**外中断指来自CPU执行指令以外的事件，如时钟中断、设备I/O中断等；内中断是指源于CPU执行指令发生的事件，如地址越界、非法操作码等。

13. 从用户态进入内核态的**唯一途径**是**中断（系统调用是一种中断）或异常**。

14. **大内核**将操作系统的主要功能模块都作为一个紧密联系的整体运行在内核态，但是由于功能太多导致代码难以维护；**微内核**分离了内核与服务，使得他们之间的接口更加清晰，但是由于频繁在用户态与内核态之间切换开销较大。



## 进程管理

1. 进程是系统进行**资源分配和调度**的基本单位，进程的实体包括**程序段、相关数据、PCB（进程控制块）。PCB是进程存在的唯一标志。**

2. 进程的5种状态：

   1. **运行状态**：正在处理机上运行；
   2. **就绪状态**：获得了**除处理机以外的一切资源**，就在等待处理机；
   3. **阻塞状态**：在等待**除处理机以外的某一种或多种资源**；
   4. **创建状态**：正在被创建；
   5. **结束状态**：正常结束或中断；

3. 进程创建的步骤：分配一个PCB（PCB是有限的），分配内存（如果失败则进入**阻塞**），初始化PCB，加入就绪队列；

4. PCB包含：**进程标识符、用户标识符、当前状态、优先级、所分配的资源、处理机的相关信息等；**程序段就是源代码，**这个可以多个进程共享**；数据段就是运行中的结果等。

5. 管道是一种**特殊的文件，是一个大小固定的缓冲区。**管道是采用**半双工通信**，即数据可以双向流动，但是同一时刻只能读或者写。

6. **线程是系统独立调度和分配的基本单位**，线程不自己**不拥有系统资源**，虽然拥有自己的ID、堆栈等，但是与进程中的其他线程竞争资源。

7. **进程与线程的区别：**

   ①进程是**资源分配**的基本单位，线程是**CPU调度**的基本单位；

   ②由于创建和撤销进程系统需要**分配或回收内存空间、I/O设备等**，所以进程的切换开销比线程大很多；

   ③各个进程之间地址空间**相互独立**，一个进程中的所有线程**共享**进程的资源；

   ④进程间通信需要**同步互斥**手段辅助，线程间通信可以通过读写数据段；

8. 一个作业从提交到完成，需要经历：**作业调度（高级调度，即建立进程）、内存调度（中级调度，目的是为了提到内存利用率和系统吞吐量，主要用于维护阻塞、就绪队列）、进程调度（低级调度，将CPU分配给就绪队列中的一个进程）**，级别越低，发生频率越高。

9. 调度方式分为：**非剥夺调度（只有当前运行进程完成时间片之后才可以切换进程），剥夺调度（使得运行的进程立即停止）。**

10. 调度算法：

    1. **FCFS先来先服务**

       非剥夺调度方式，新进入就绪队列的作业先分配CPU。

    2. **SJF短作业优先**

       从就绪队列中选择所需运行时间最短的作业分配CPU，可能会造成**饥饿现象**。

    3. **优先级调度算法**

       根据任务的优先级分配CPU。

    4. **高响应比优先**

       响应比=（等待时间+所需运行时间）/所需运行时间，是FCFS和SJF的结合。

    5. **时间片轮转**

       适用于分时系统。时间片**过大会退化为FCFS，过小会由于频繁切换开销过大。**

    6. **多级反馈队列**

       维护多个优先级的就绪队列，**优先级越高，时间片越小**，第i+1级的时间片大小是第i级的2倍。所有进程首先放在优先级最高的1级队列中，按照FCFS原则分配CPU；如果能够完成作业则撤离，如果不能则加入第2级队列的末尾；以此类推，直到完成为止；如果中途有优先级更高的进程，**会采取剥夺方式抢占CPU**，正在运行的进程放回当前队列的末尾。

11. 同一时刻**只允许一个进程**访问的资源称为**临界资源**，访问临界资源**必须互斥**进行，访问临界资源的**代码**称为**临界区**。

12. **同步**中的PV操作是分别由两个进程完成，**互斥**中的PV操作是一个进程完成的。

13. **管程**是**由局部于自己的若干公共变量及其说明和所有访问这些公共变量的过程所组成的软件模块。**管程的特点为**管程封装了同步操作，对进程隐蔽了同步细节，简化了同步功能的调用界面；**使用管程是为了解决**1、把分散在各进程中的临界区集中起来进行管理；2、防止进程有意或无意的违法同步操作；3、便于用高级语言来书写程序，也便于程序正确性验证。**管程很像一个抽象类，其属性有：①所有进程都可以访问管程；②**同一时刻只能有一个进程**访问管程；③管程的内部变量只能通过其内部方法访问，也不能使用管程内部方法访问别的类的变量；④通过设置管程的内部变量，可以通过管程实现对一些临界资源如打印机的访问。

14. 经典同步问题：

    1. **生产者-消费者问题**

       有一个大小为N的缓冲区，当N未满的时候生产者才可以投入产品，当N不为空的时候消费者才可以取得产品。

       缓冲区必须互斥访问，所以**多个生产者是互斥关系**；生产者和消费者是**同步关系**；

    2. **读者-写者问题**

       对于一个共享的文件F，允许多个读者同时执行读操作，只允许一个写者执行写操作，且写操作完成之前不允许别的读者写者访问F。

       解决思路为设置一个互斥锁M、写操作锁W、读操作锁R（修改cnt必须互斥进行），计数cnt。**写操作和读操作**都需要先取得M，

       ①如果读者取得M，检查cnt==0，则取得W且cnt++，然后释放M；

       ②下一个读者先取得M，然后检查cnt！=0，则cnt++即可，释放M；

       ③写者取得M，则开始等待W，取得W后执行写操作，写完之后释放W和M；

       ④读者完成读操作以后，先将cnt--，检查cnt==0则释放W，否则直接离开；

    3. **哲学家进餐问题**

       五个哲学家五支筷子，每只筷子由两个人共享，只有取得左右两支筷子才可以进食。

       运用贪心算法可能导致**死锁**，最稳妥的方法是只有所有资源都满足的情况下才占有。

    4. **吸烟者问题**

       有三个抽烟者和一个供应者，想抽烟必须获得三种不同的材料，每个抽烟者持有其中的一种材料，供应者每次供应其中两种材料，让抽烟者轮流抽烟。

       供应者和抽烟者**同步**，抽烟这件事件**互斥进行**。

15. **死锁是指多个进程因竞争资源而造成的一种互相等待的情况，如无外力作用，所有进程都无法继续运行。**

    死锁产生必须满足四个条件：**互斥条件、非剥夺条件、请求和保持条件、循环等待条件。**

    死锁处理策略：

    1. 死锁预防：破坏产生死锁的四个条件的其中一个，一般采取只有所有资源都满足的时候才分配的策略来破坏**请求和保持条件。容易产生饥饿现象。**

    2. 死锁避免：资源分配之前先计算**此次资源分配的安全性**，只有系统不会进入不安全状态的情况才进行分配，否则让程序等待。最著名的死锁避免算法是**银行家算法**：

       ①进程首次申请资源时，先测试其**最大需求量max是否小于系统持有量**，满足则分配当前其申请的资源量；

       ②再次申请时，测试其**已占有和这次申请的和是否小于最大需求量max**，满足则再测试**系统可用资源是否满足此次分配**，是则分配，否则等待；

       **银行家算法的核心是安全性算法**，目的是找到一个不会发生死锁的执行顺序。具体做法为：

       ①计算当前进程资源持有矩阵allocation和最大需求矩阵max；

       ②计算剩余需求矩阵need=max-allocation；

       ③用系统当前空闲资源向量available对比need中的每一个进程需求；

       ④找到满足的一个进程分配，然后将这个进程的max向量+分配后的available向量；

       ⑤以此类推，直到所有的进程都能够完成；

    3. 死锁检测和解除

       1. 检测使用**死锁定理**：在资源分配图中找到**不阻塞且不是孤点**的进程，然后去掉其所有有向边，释放所有资源；以此类推进行简化，如果最终资源分配图无法完全简化，则出现死锁。
       2. 解除的办法：**资源剥夺、进程撤销、进程回退。**撤销是直接终止，回退只是回溯到未发生死锁的状态，而不是终止。



## 内存管理

1. 将**源程序**变为**可执行程序**一般包括：**编译、链接、装入。**

   1. 编译：由编译程序将源代码编译成若干个目标模块；
   2. 链接：由链接程序将编译得到的目标模块与**所需的库函数**链接在一起；
      1. 静态链接：运行之前将**目标模块与所需库函数链接在一起，不再拆开；**
      2. 装入时动态链接：装入内存是边装入边链接；
      3. 运行时动态链接：运行时按需链接；**便于修改和更新，便于实现对目标模块的共享。**
   3. 装入：装入内存运行；一般有以下三种方式：
      1. 绝对装入：程序按照**绝对地址**装入内存，只适合单道程序环境；
      2. 静态重定位：程序装入的地址只是**相对地址**，但是静态重定位装入后**不能再次请求分配内存也不能移动。**
      3. 动态重定位：程序可以每次**只装入部分代码**运行，期间还可以**再次申请分配内存，并且可以移动。**

2. 编译后的每个目标模块都是从0号单元开始编址的，称为目标模块的**相对地址（逻辑地址）。**链接程序连接所有模块后会生成统一的以0号单元开始编制的**逻辑地址空间，**可以映射到主存的不同位置。

3. 为了保护内存中的进程互不干扰，采用了**重定位寄存器**和**界地址寄存器**。重定位寄存器表示程序执行的**物理地址的最小值**，界地址寄存器表示程序执行**逻辑地址的最大值**。首先比较逻辑地址与界地址寄存器，没有越界则将逻辑地址+重定位寄存器=物理地址，然后开始执行。

4. 扩充内存的主要方法分为：**交换（不同进程之间）、覆盖（同一进程之间）。**

5. 内存的**连续分配**管理方式：

   1. 单一连续分配：只适用于单任务操作系统；

   2. 固定分区分配：有**固定大小**分区和**递增大小**分区两种。由于每个程序会占用一整块分区，所以会产生**内部碎片**，主存利用率降低，但是没有外部碎片。

   3. 动态分区分配：不预先划分内存，按程序实际需要**动态划分**。程序的大小就是分区的大小，所以没有内部碎片，但是会存在**外部碎片**，可以通过**紧凑**技术解决。

      动态分区的策略：

      1. 首次适应：空闲分区**按地址排序**，返回第一块合适的空闲分区；
      2. 最佳适应：空闲分区**按分区大小增序排列**，返回第一块合适的空闲分区；
      3. 最坏适应：空间分区**按分区的大小降序排列**，返回第一块合适的空闲分区；
      4. 邻近适应：首次适应的改版，每次查找**从上一次分配的空闲分区后面开始查找**，返回第一块合适的空闲分区；

      在回收内存的时候，需要对相邻的空闲分区进行合并。

6. 内存的**非连续**分配方式：

   1. 基本分页存储管理方式：分页管理**不会产生外部碎片。**进程运行时按照需要申请内存块，所以只有**最后一个块会产生内部碎片。**

      分页存储的地址结构决定了**每个页的大小和虚拟内存寻址空间的大小。**例如：地址结构为32位，0-11位为页内偏移量，也就是说页面的大小2的12次方=4KB；12-31位为页号，也就是说说总共有2的20次方个页面。

      为了找到进程每个页面对应的物理块，系统为**每个进程建立一个页表保存在内存。**页表表示了**页号**和**物理内存中块号**的对应关系。在此情况下，每次寻址需要**访问两次内存：第一次找到这个地址，第二次到达这个地址返回数据。**因此，根据**局部性原理（①当前执行的指令很可能会再次执行；②当前访问的数据其附近的数据可能会在近期访问）**设计了快表，每次访问某个页面的时候，先去快表查找，没找到再去页表中查找，每次将当前查找的页附近的页加入到快表，根据一定算法对快表内元素进行替换。

   2. 基本分段存储管理方式：

      分段与分页的最大区别在于**页大小是固定的，段大小由程序实际长度决定。**段表项包括段号、段长度、本段在主存的开始地址。段的地址结构为段号、段内偏移量。**由于段内要求连续，段间不要求连续，所以这种方法会造成外部碎片。**寻址过程：首先，根据段表项找到本段开始地址，然后加上段内偏移量计算开始执行的地址。

   3. 段页式管理方式：

      首先将系统的地址空间**分成段、然后再将每一段分成页**。段页式系统的逻辑地址结构为段号、页号、页内偏移量；段表结构为段号、页表长度、页表开始地址；系统为**每一个进程建立一个段表**，寻址过程：首先，通过段表找到段的开始地址，然后加上页号*页面大小再加上页内偏移量得到物理地址。

7. **虚拟内存**：使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。虚拟内存的实现：

   1. 请求分页存储管理：

      请问分页系统**不要求全部程序一次性调入内存，只需要调入当前执行的那部分即可。**请求分页中的页表项包括**页号、物理块号、状态位P（是否已调入内存）、访问字段A（最近被访问的次数或最近被访问的时间）、修改位M（该页内容是否修改）、外存地址。**

      寻址过程：首先在快表中查找（**快表中的页面肯定在内存中**），如果找到了就修改访问字段A和修改位M，返回物理地址；如果没找到就查找页表，查看状态位P，如果在内存中则修改快表和A、M；如果不在则保留CPU现场，如果内存未满则直接调入内存，如果内存满了就要找一页替换。

      **页面置换算法**

      1. 最佳置换算法（OPT）：置换未来不会用到的页，由于无法预测未来要用哪一页，无法实现；

      2. 先进先出法（FIFO）：优先淘汰**最早进入内存的页面**。FIFO算法会产生**内存增大反而缺页中断次数不降反增的---Belady异常**。

      3. 最近最久未使用（LRU）：淘汰最近**最长时间未被访问的页面**，FIFO是淘汰最早进入内存的页面，而不管最近有没有被访问。

      4. 时钟置换（CLOCK，**也称为NRU---最近未用**）：以u表示最近被访问，m表示被修改

         ①第一次扫描，找到第一个u=m=0的帧进行替换；

         ②再次扫描，找到第一个u=0，m=1的帧进行替换，**过程中跳过的页面u置0；**

         ③失败则回到①，还是失败则进入②，不断循环；

8. 抖动：频繁发生页面中断。主要原因是可用的物理页面太少。

9. 虚拟内存的大小受制于两个因素：

   ①虚拟内存的大小 ≤ 内存+外存；

   ②虚拟内存的大小 ≤ 计算机地址位数能容纳的最大容量；比如32位系统，如果我把这32位全部用于编址，最多也就2的32次方=4GB,那么超过4GB部分的虚拟内存无法访问。



## 文件管理

1. 文件是以计算机硬盘为载体存储在计算机上的信息集合。

2. 文件的逻辑结构是用户看到的结构，与物理结构不同，与存储介质的特性无关。可分为：

   1. 无结构文件

      是最简单的文件组织形式。无结构文件将数据按顺序组织成记录并积累保存。

   2. 有结构文件

      可分为顺序文件（将**定长的记录**按顺序以**链表**的形式存储）、索引文件（建立一张索引表加快不定长文件的查找速度，**索引表本身是顺序文件**）、索引顺序文件（将顺序文件分为若干组，为其建立索引表）。

   3. 散列文件（Hash File）

      将文件名与物理地址通过哈希表记录。

3. 每个文件对应一个**FCB（文件控制块）**，其中记录了文件名、物理位置、逻辑结构、权限、修改时间等信息。

4. 文件的目录结构

   1. 单机目录结构：

      整个文件系统只有一个目录表，每一项对应一个文件，**查找速度满，不能重名，不便于共享。**

   2. 两级目录结构

      将目录分为主文件目录（MFD）和用户文件目录（UFD），每个用户占一个目录，MFD记录用户名及其用户文件目录的地址，UFD对应这个用户的文件的物理地址。**缺乏灵活性，不能对文件进行分类。**

   3. 多级目录结构

      两级目录结构的拓展，从根目录”/"出发的（开头是"/"）称为**绝对地址**，从当前目录出发的（开头一般是"./"）称为**相对地址**。

   4. 无环图目录结构

      **为了实现文件共享**，对于同一个文件，会有多个连线表示多个用户共享次文件。因此，会有一个计数器记录连接个数，只有连接为0才能删除文件。

5. **基于索引节点的共享（硬链接）**

   因为索引节点可以唯一标记文件的位置，所以硬链接表示所有的用户都可以通过硬链接访问文件，因此，会有一个计数器记录连接个数，只有连接为0才能删除文件。

   **基于符号链实现的共享（软链接）**

   创建一个包含被链接文件路径名的符号链接文件，可以通过该文件访问被链接文件，相当于快捷方式。

6. 可以通过**口令保护（创建的时候提供口令存在FCB，访问文件需要提供口令，但是口令就在系统内部，不够安全）、加密保护（访问文件需要密钥）、访问控制（拥有组、组、其他人的权限）**实现文件的保护。

7. 用户访问文件F的过程：

   ①通过**用户调用接口**对操作系统发出访问文件F的命令；

   ②系统通过**文件目录系统**查找到文件F的FCB；

   ③系统通过**存取控制验证层**在FCB上检查用户是否对文件F有访问权限；

   ④通过**逻辑文件系统**得到对应文件的逻辑地址；

   ⑤从逻辑地址中换算得到**物理地址**；

   ⑥将读取文件F的任务交给**辅助分配模块**；

8. 目录一般通过**线性表和哈希表**实现。

9. 文件存储设备管理的实质上是对**空闲块的组合和管理**。

   1. 空闲表法：将所有空闲块使用一个表记录起来；
   2. 空闲链表法：将所有的空闲块用链表连接；
   3. 位示图法：用一块二维的空间表示对应块的使用情况；
   4. 成组链表法：**在大型文件系统，空闲表和空闲链表都会导致表过大**，UNIX系统使用成组链表法。把顺序的n个空闲扇区地址保存在第一个空闲扇区里，然后最后一个保留一个指针指向下一个空闲扇区索引表的空闲扇区。

10. 磁盘盘面上有很多同心圆，每一个圆环称为一个**磁道**；磁道又可以划分为很多个**扇区**；磁盘的存储能力受限于**最内道的最大记录密度**。

11. 磁盘调度算法：一次磁盘读写操作包括**寻道时间（寻找磁道）、延迟时间（寻找扇区）、传输时间（I/O所需时间）。**

    1. FCFS先来先服务

       按照指令到达先后顺序执行寻找，但是平均寻找长度比较大；

    2. SSTF最短寻找时间优先

       优先处理离当前磁头最近的磁道寻找请求，可能会产生**饥饿**。

    3. SCAN扫描算法（电梯算法）

       优先选择**当前移动方向**上距离最近的寻找请求进行服务，直到该方向没有寻找任务才**换向**；

    4. C-SCAN循环扫描

       磁头**永远单向**运动，到达该方向的最后一个寻找指令后返回到起点，继续沿着该方向寻找；



## 输入/输出（I/O）管理

1. 外围设备与内存的I/O方式：

   1. **程序直接控制**

      CPU与I/O设备串行工作，CPU利用率低；

   2. **中断驱动方式**

      CPU向I/O控制器发送读命令之后先去执行别的任务，I/O控制器读取完毕之后，**向CPU发出中断信号**，CPU开始将数据存入内存；

   3. **DMA（直接存储器存储）方式**

      DMA方式的特点：①基本单位是数据块；②数据直接传入内存，或者相反；③仅在开始和结束的时候需要CPU干预，其他时候自主控制；

   4. **通道控制方式**

      对比DMA，通道不需要CPU控制数据块的大小，传输的内存位置。

2. I/O系统的层次结构：

   1. 用户层I/O软件：实现与用户交互的接口，**必须通过系统调用**获取操作系统服务；
   2. 设备独立性软件：主要用于执行所有设备的公有操作和向用户提供统一接口；
   3. 设备驱动程序：将用户的I/O命令转换为设备能理解的形式；
   4. 中断处理程序：用于保存被中断进程的CPU环境；
   5. 硬件设备：提供服务的硬件；

3. 缓冲区（buffer）：为了解决高速CPU与低速I/O设备之间的矛盾。**特点**：缓冲为空才能写，缓冲为满才能读。

   1. 单缓冲：CPU总是等待I/O把缓冲区充满；
   2. 双缓冲：CPU读取缓冲1的同时，I/O向缓冲2写入数据，以此类推；
   3. 循环缓冲：多个缓冲区形成一个环形，有两个指针，一个指向充满的第一个缓冲区，另一个指向可以写入数据的下一个缓冲区；
   4. 缓冲池：多个系统公用的缓冲区组成。维护缓冲队列、输入队列、输出队列。

4. **SPOOLing技术（假脱机技术）**：将独占设备改造成共享设备。

   首先在**磁盘**上开辟两个缓冲区**输入井、输出井**；然后在**内存**上开辟两个缓冲区**输入缓冲、输出缓冲**；当CPU需要输入数据，就从**输入井读入内存输入缓冲**；当需要输出数据，就从**输出缓冲输出到输出井**，待设备空闲的时候再处理这些任务。

   优点：提高了I/O速度，改造了独占设备为共享设备，实现虚拟设备。

